## 一、面试题

### 1. 什么是云计算，说说你的理解；云计算的优点有哪些？⭐⭐⭐

云计算是一种通过**计算机网络**以服务的方式提供**动态可伸缩的虚拟化资源**的 **计算模式** 。按照服务层次分为IaaS、PaaS和SaaS三个层次；按照部署方式可以分成公有云、[私有云](https://zhida.zhihu.com/search?content_id=239329008&content_type=Article&match_order=1&q=%E7%A7%81%E6%9C%89%E4%BA%91&zhida_source=entity)和混合云。

 **云计算优点** ：

* 弹性伸缩：云计算可以根据业务需求自动调整计算资源，使应用程序可以在高峰期和低谷期之间自由地进行伸缩。
* 资源共享：云计算可以将计算资源、存储资源和网络资源等进行共享，从而实现资源的高效利用。
* 成本效益：云计算可以提供按需计费的服务模式，避免了购买昂贵的硬件设备和维护成本。
* 可靠性：云计算通常采用分布式架构，具有高可用性和容错性，能够保证应用程序的可靠性和稳定性。
* 可移植性：云计算可以将应用程序部署在不同的云平台上，从而实现应用程序的跨云平台移植和运行。

### 2. 云计算服务类型⭐⭐⭐

IaaS、PaaS、SaaS

### 3. 云计算部署类型，区别是什么？⭐⭐⭐

公有云、私有云和混合云

公有云：由 **云服务提供商提供的基础设施和服务** ，用户可以按需购买、使用和支付。例如 Amazon Web Services（AWS 亚马逊）。

私有云：在用户自己的数据中心或机房中搭建的云计算环境，用于满足特定的安全、隐私或合规需求。 **私有云的核心特征是云端资源仅供某一客户使用，其他客户无权访问** 。

混合云：用户同时使用公有云和私有云的模式。一方面，用户在本地数据中心搭建私有云，处理大部分业务并存储核心数据；另一方面，用户通过网络获取公有云服务，满足峰值时期的IT资源需求。

 **公有云和私有云的区别** ：

1. 拥有权：公有云是由第三方提供商拥有和管理的云计算平台，面向社会大众使用；私有云是由企业或组织自己构建和管理的云计算平台，只提供给企业或组织内部的用户使用。
2. 费用：公有云通常采用按需付费模式，用户只需支付其实际使用的资源费用。私有云则需要企业或组织自行投资购买硬件设备、建设数据中心。
3. 安全性：公有云平台通常具有较高的安全性，其服务商会采取一系列措施来保护用户数据安全。而[私有云平台](https://zhida.zhihu.com/search?content_id=239329008&content_type=Article&match_order=1&q=%E7%A7%81%E6%9C%89%E4%BA%91%E5%B9%B3%E5%8F%B0&zhida_source=entity)的安全性则取决于企业或组织自身的安全能力和措施。
4. 灵活性：公有云平台具有较高的灵活性，可以根据用户需求动态调整资源。私有云则由企业或组织自行管理，资源调整相对较为困难。
5. 可扩展性：公有云平台可以随时增加和释放资源，具有较高的可扩展性。私有云则需要企业或组织自行投资增加硬件设备和数据中心，扩展性相对较低。

 **混合云则是介于两者之间** 。

### 4. 云计算与传统物理服务器相比的好处⭐⭐⭐

云计算主要是租用云服务器，相对于物理服务器来说：

1. 成本低。物理服务器实体价格较贵；而云服务器主要是租用计算资源，价格便宜。
2. 可伸缩性好。云服务器可以动态扩缩容，资源可以充分利用；而物理服务器可伸缩性差，造成资源浪费。
3. 安装周期短。云服务器可以申请任意类型的操作系统的服务器，申请就能用，缩短了安装的周期。而物理服务器买来时是裸机，需要运输、安装，同时需要根据客户情况安装操作系统或应用。

| 成本     | 高 | 低 |
| -------- | -- | -- |
| 可伸缩   | 差 | 强 |
| 安装周期 | 长 | 短 |

### 5. 说说你对IaaS、PaaS、SaaS的理解。它们各自的优缺点是什么？⭐⭐⭐

1. IaaS（Infrastructure as a Service）的缩写，即基础设施即服务IaaS是一种云服务，提供基本的计算基础结构：服务器（CPU），存储（内存、磁盘）和网络资源（ip与端口）。通俗来说，就是把物理服务器资源，如CPU、内存、磁盘虚拟化，放入一个资源池里，客户端按需申请使用。
2. PaaS（Platform as a Service）的缩写，即平台即服务PaaS是指为运行时环境提供用于开发，测试和管理应用程序的云平台。很好理解，PaaS就是在IaaS的基础上把运行时环境、中间件、操作系统也都给你装好了，而客户端就在PaaS上安装应用程序，生产个人数据。用户只需要关注自己的业务逻辑，而不需要关注底层。
3. SaaS（Software-as-a-Service）的缩写，即软件即服务SaaS允许人们使用基于云的Web应用程序。SaaS就更方便了，直接在PaaS的基础上把应用程序都安装好了，生成的数据也都在云服务器上，客户端只需要连接上网络就可以直接使用应用。

| IaaS | 灵活自由，可定制性强             | 管理和运维成本高             |
| ---- | -------------------------------- | ---------------------------- |
| PaaS | 无需关心基础设施，专注于应用开发 | 自由度和灵活性受到限制       |
| SaaS | 无需关心管理和运维，快速使用     | 自由度和灵活性受到更多的限制 |

### 6. 什么是虚拟化技术？请列举几种常见的虚拟化技术类型。⭐⭐

虚拟化技术是指通过软件或硬件的方式，将一台物理计算机划分成多个虚拟计算机（即 **虚拟计算单元** ），使得每个虚拟计算机都能够独立运行自己的操作系统和应用程序，并且可以被看作一台完整的计算机。虚拟化技术可以提高计算机资源的利用率，降低硬件成本和维护成本，方便系统管理和资源调度。

 **常见的虚拟化技术类型包括** ：

* 容器虚拟化：容器虚拟化是一种轻量级的虚拟化技术，利用操作系统的进程隔离机制实现多个应用程序在同一操作系统上独立运行的目的。
* 硬件虚拟化：硬件虚拟化是一种基于虚拟机监控器（VMM）的虚拟化技术，可以在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机都能够独立运行自己的操作系统和应用程序。
* 网络虚拟化：网络虚拟化是一种将物理网络资源划分成多个逻辑网络资源的技术，可以实现网络资源的隔离、复用和优化。
* 存储虚拟化：存储虚拟化是一种将多个存储设备虚拟化成一个逻辑存储设备的技术，可以提高存储资源的利用率和可靠性。

### 7. 请简述云计算中的弹性计算概念，以及如何实现弹性计算⭐⭐

 **弹性计算是指在云计算环境中，根据业务需求动态调整计算资源的能力** 。它可以根据应用程序的需求增加或减少计算资源，以便更好地应对突发的高负载或低负载情况。弹性计算的目标是确保在任何时候，应用程序都能够获得足够的计算资源，以满足用户的需求。

实现弹性计算可以采用以下方法：

* 自动伸缩：通过设置自动伸缩规则，根据应用程序的负载情况自动调整计算资源的数量。
* 水平扩展：增加计算节点的数量，以适应应用程序的负载情况。
* 垂直扩展：增加单个计算节点的计算能力，以提高计算资源的利用率。
* 弹性资源池：在云计算环境中建立一个弹性资源池，根据应用程序的需求动态调配计算资源。
* 服务治理：通过服务治理技术，对应用程序进行负载均衡和容错处理，以保证应用程序的高可用性和性能。

### 8. 什么是云计算？它与传统的 IT 架构有何不同之处？⭐⭐

同第一题

### 9. 云计算的安全性如何？有哪些安全措施可以采取？⭐⭐

云计算的安全性是用户关注的一个重要问题。由于云计算涉及多个用户共享同一物理资源，因此存在安全隐患，例如数据泄露、DDoS攻击、虚拟机逃逸等。

为了确保云计算的安全性，可以采取以下安全措施：

1. 访问控制：云计算平台应该实现严格的访问控制机制，包括身份验证、授权、审计等，确保只有授权用户可以访问云资源。
2. 数据加密：用户应该对存储在云计算平台上的敏感数据进行加密，以防止数据泄露和窃取。
3. 网络隔离：云计算平台应该实现网络隔离机制，确保不同用户之间的网络流量不会相互干扰，以及防止DDoS攻击和网络嗅探等。
4. 虚拟化安全：虚拟化技术是云计算的核心，但它也存在安全隐患。用户应该采取措施，如使用安全的虚拟机映像、加强虚拟机间的隔离和监控等。
5. 备份和恢复：云计算平台应该实现完善的备份和恢复机制，确保用户数据在意外事故发生时能够及时恢复。
6. 安全审计：云计算平台应该实现安全审计机制，记录所有访问和操作行为，以便对安全事件进行调查和审计。

### 10. 什么是弹性扩展？它在云计算中有何应用？⭐⭐

 **弹性计算是指在云计算环境中，根据业务需求动态调整计算资源的能力** 。它可以根据应用程序的需求增加或减少计算资源，以便更好地应对突发的高负载或低负载情况。弹性计算的目标是确保在任何时候，应用程序都能够获得足够的计算资源，以满足用户的需求。

弹性扩展在云计算中应用广泛，例如：

1. 网站负载均衡：当用户访问量增加时，可以自动增加Web服务器的数量，以满足用户的请求需求。
2. 数据库扩展：当数据库负载增加时，可以自动增加数据库服务器的数量，以提高数据库的性能和可用性。
3. 流媒体服务：当用户观看流媒体内容时，可以自动增加视频服务器的数量，以提供更好的用户体验。
4. 大数据处理：当处理大数据时，可以自动增加计算服务器的数量，以加快数据处理的速度。

### 11. 云计算中的容器技术有哪些？它们的作用是什么？⭐⭐

在云计算中，容器技术是一种虚拟化技术，它允许应用程序在独立的容器中运行，而不需要为每个应用程序提供完整的虚拟机。这样可以更有效地利用计算资源，更快速地部署和扩展应用程序，并提高系统的可移植性和安全性。

以下是一些常见的容器技术及其作用：

1. Docker：Docker 是最流行的容器化平台之一。它提供了一种轻量级的虚拟化技术，使得应用程序可以在不同的环境中轻松地移植和运行。Docker 还提供了一系列工具和功能，帮助用户快速构建、部署和管理容器。
2. Mesos：Apache Mesos 是一个开源的分布式系统内核，它可以让用户将计算资源池化为一个虚拟的计算机集群。Mesos 可以管理多个应用程序和服务，提供资源分配、容器编排、负载均衡等功能，使得用户可以更有效地利用计算资源，提高系统的可靠性和可扩展性。
3. LXC/LXD：LXC 是一种基于 Linux 容器的虚拟化技术，它允许用户在独立的容器中运行多个应用程序。LXD 是一个基于 LXC 的容器编排工具，它可以帮助用户轻松管理和扩展容器集群，提供负载均衡、自动伸缩等功能。

## 二、面试题

### 1. 容器技术的优势⭐⭐

1. 资源利用率高：容器使用的资源非常少，容器之间可以共享操作系统的内核，避免了多个虚拟机之间资源浪费和冗余，因此相比传统虚拟化技术可以更好地利用物理服务器的资源。
2. 快速启动和停止：由于容器本身就是轻量级的进程，因此容器可以非常快速地启动和停止。这使得容器技术非常适合用于动态伸缩和弹性扩展等场景。
3. 隔离性强：容器之间相互隔离，不会相互干扰，保证了应用程序的稳定性和安全性。同时，容器技术提供了多种隔离机制，例如网络隔离、文件系统隔离、进程隔离等。
4. 灵活性强：容器技术可以跨平台使用，支持多种操作系统和硬件架构，同时容器技术可以方便地将应用程序打包和分发，提高了应用程序的可移植性和可重复性。
5. 管理和部署简单：容器技术可以很方便地实现应用程序的管理和部署，容器镜像可以轻松地进行版本控制和更新，同时容器编排工具可以实现自动化部署和运维。

### 2. 虚拟机技术与容器虚拟化技术对比⭐⭐

1. 虚拟机技术需要在宿主机上安装虚拟化软件，然后在虚拟化软件上安装操作系统和应用程序。每个虚拟机都有自己的操作系统内核和资源管理器，因此虚拟机可以运行不同版本的操作系统和应用程序。容器虚拟化技术则不需要虚拟化软件，而是在宿主机的操作系统上运行，共享主机的操作系统内核。每个容器都有自己的用户空间，但共享主机的内核和系统资源。
2. 虚拟机技术提供了更高的隔离性和安全性，因为每个虚拟机都运行在独立的环境中，并且可以配置不同的安全策略和网络设置。容器虚拟化技术虽然也提供了一定的隔离性，但容器之间仍然共享主机的操作系统内核和系统资源，因此容器之间可能存在潜在的安全风险。
3. 虚拟机技术需要更多的资源，例如内存和处理器，因为每个虚拟机都需要运行一个完整的操作系统内核和资源管理器。容器虚拟化技术则可以共享主机的操作系统内核和系统资源，因此需要更少的资源，并且可以更高效地运行。
4. 虚拟机技术通常需要更长的启动时间，因为需要启动完整的操作系统和资源管理器。容器虚拟化技术启动时间更短，因为只需要启动容器的用户空间。

![](https://pic4.zhimg.com/v2-48cb6c95c2baec753e97635bda79056d_1440w.jpg)

![](https://pic2.zhimg.com/v2-5dd02d76448ac81429b196c5fad87043_1440w.jpg)

## 三、面试题

### 1. ISO 镜像文件了解嘛？⭐⭐

ISO 镜像文件是一种用于存储光盘或 DVD 的镜像文件格式。它是将光盘或 DVD 中的所有内容以二进制格式复制到一个文件中，包括文件系统、引导记录、文件和目录等等。

ISO 镜像文件通常具有扩展名为 .iso。它可以用于创建一个完全相同的副本，这个副本可以用于安装操作系统、软件应用程序或其他类型的数据。

比如我们创建虚机，通常需要一个 ISO 镜像文件来安装操作系统。

### 2. VMWare 创建虚拟机三种网络模式⭐⭐

1. 桥接模式（Bridged Mode）：桥接模式允许虚拟机与物理网络上的其他设备连接到同一个网络中，虚拟机可以与局域网内的其他设备进行通信，就像它们连接到同一个物理交换机上一样。虚拟机可以获得网络上的 IP 地址，访问 Internet 和其他网络资源，同时其他设备也可以通过网络访问虚拟机。
2. NAT 模式（Network Address Translation Mode）：NAT 模式允许虚拟机与宿主机之间建立连接，并共享宿主机的网络连接。虚拟机可以通过 NAT 模式访问 Internet 和其他网络资源，但是局域网内的其他设备无法直接访问虚拟机。此模式适合在虚拟机中进行测试和开发，但需要访问 Internet 和其他网络资源。
3. 主机模式（Host-Only Mode）：主机模式允许虚拟机与宿主机之间建立连接，但不允许虚拟机直接访问 Internet 和其他网络资源。虚拟机可以与宿主机之间进行通信，但无法与局域网内的其他设备通信。此模式适合在虚拟机之间建立局域网，并对其进行测试和开发。

## 四、面试题

### 1. 什么是 Docker？有什么优点？⭐⭐⭐

Docker 是一种容器化技术，它可以将应用程序及其依赖项封装为一个独立的容器中。Docker 的优点包括：

* 将应用对应的系统配置和SDK依赖打包成一个镜像文件，在环境上直接通过镜像创建容器并运行，简化了应用程序的部署过程；
* 提供了轻量级的虚拟化，只需要将应用对应的系统配置和SDK依赖打包成一个镜像文件，而不需要一个完整的操作系统，避免了虚拟机带来的额外开销；
* 可以更好地管理不同应用程序之间的依赖关系和版本，因为镜像可以有不同的版本，通过 `docker images` 来管理；
* 更容易迁移和扩展应用程序，这就是镜像文件的好处；
* 可以更好地保证应用程序在不同环境中的一致性，这就是镜像文件的好处。

### 2. Docker 的基本组件有哪些？⭐⭐⭐

1. 服务端 Docker 进程（Server Docker Daemon）：负责管理 Docker 容器和镜像；处理客户端的请求，并执行相应的操作。
2. API 接口（REST API）：为 Docker 客户端提供与服务端 Docker daemon 交互的接口。
3. Docker 客户端命令行（Client Docker CLI）：允许用户与服务端 Docker daemon 交互，客户端发送的一系列请求，例如运行容器、构建镜像等操作，将最终由服务端 Docker daemon 来执行。
4. Docker 镜像（Images）：是一个轻量级、可执行的软件包，其中包含了运行应用程序所需的所有代码、库、配置文件等。容器镜像可以通过运行容器来启动，容器会使用镜像创建一个独立的运行环境，包含容器镜像中的所有文件和依赖项。
5. Docker 容器（Containers）：是 Docker 中的运行时实体，包含了应用程序及其依赖关系，可以被启动、停止、重启、删除等操作。
6. Docker 网络（Networks）：允许容器之间进行通信，并提供网络隔离、端口映射等功能。
7. Docker 存储（Data Volumes）：提供容器内部数据的持久化存储功能，包括数据卷、本地文件系统、网络存储等。

### 3. Docker 镜像是如何创建的？如何分享 Docker 镜像？⭐⭐⭐

Docker 镜像可以通过 Dockerfile 文件创建，Dockerfile 文件描述了如何构建 Docker 镜像，包括基础镜像、应用程序代码、运行环境等。在 Dockerfile 文件所在的目录下，使用 `docker build` 命令可以构建 Docker 镜像。

要分享 Docker 镜像，可以将其推送到 Docker Hub 或者其他 Docker 镜像仓库中。使用 `docker tag` 命令可以给镜像打上标签，然后使用 `docker push` 命令将镜像推送到仓库中。别人在使用时通过 `docker pull` 拉取镜像。

### 4. Docker 镜像和容器的区别是什么？⭐⭐⭐⭐

1. 镜像是一个只读的模板，用于创建 Docker 容器。镜像可以看作是一个容器的静态版本，包括应用程序代码、运行环境、依赖项等。镜像通常是由 Dockerfile 或者从其他镜像派生而来，可以通过 Docker Hub 或者本地仓库获取。
2. 容器是由 Docker 镜像创建而来的可运行实例，包括应用程序的运行状态、环境变量等信息。容器可以看作是一个镜像的运行时实例，它可以被启动、停止、删除等。容器通常是基于镜像创建的，并且容器的变化不会影响镜像。

可以简单地将 Docker 镜像看作是容器的模板，而容器是基于该模板创建出来的实例。

### 5. 说说 Docker 常用命令⭐⭐⭐

* docker run：运行一个新的容器。
* docker start：启动一个已停止的容器。
* docker stop：停止一个正在运行的容器。
* docker ps：列出当前正在运行的容器。
* docker images：列出本地镜像。
* docker build：使用 Dockerfile 构建一个新的镜像。
* docker exec：在运行中的容器中执行命令。
* docker rm：删除一个或多个容器。
* docker rmi：删除一个或多个本地镜像。
* docker network：管理 Docker 网络。

### 6. Docker 与传统虚拟机的区别什么？⭐⭐⭐

1. 资源占用：传统虚拟机需要在硬件上模拟一整套操作系统，因此每个虚拟机都需要占用大量的内存和存储空间。而 Docker 则共享主机操作系统的内核，并且只需要在容器中运行应用程序及其依赖的库，因此相比之下更加轻量级，资源占用更少。
2. 启动速度：由于传统虚拟机需要启动整个操作系统，因此启动速度通常较慢。而 Docker 采用了一种基于镜像的启动方式，可以秒级快速地启动和停止容器。
3. 部署和管理：传统虚拟机需要管理整个虚拟机，包括操作系统、安装和更新软件等，部署要安装完整操作系统和软件；而 Docker 更加简单，只需要管理容器本身即可，包括镜像、容器运行状态等。同时 Docker 将应用对应的系统配置和SDK依赖打包成一个镜像文件，在环境上直接通过镜像创建容器并运行，简化了应用程序的部署过程。
4. 移植与扩展程序：Docker 更容易迁移和扩展应用程序，通过将应用对应的系统配置和 SDK 依赖打包成一个镜像文件，上传到镜像仓库，可以在测试、生产环境中直接通过镜像创建容器并运行。
5. 资源隔离：Docker 可以更好地管理不同应用程序之间的依赖关系和版本，docker 可以同时运行多个版本的应用，不同版本的容器可以有效资源隔离；而虚拟机则较难处理多个版本应用同时运行，可能存在配置冲突、环境污染。

## 五、面试题

### 1. 什么是 Docker 镜像分层？⭐⭐⭐⭐

Docker 将一个 Docker 镜像分解成多个不同的层（Layer），每个层都是只读的文件系统，层与层之间是相互独立的。这种分层的设计可以提高 Docker 镜像的复用性和共享性。每个 Docker 镜像都是由一个或多个只读层（镜像层）和一个可读写层（容器层）组成。只读层是可以在不同镜像之间共享的，因此 Docker 的镜像可以通过利用这种分层的设计来尽可能地减少重复的数据存储，提高镜像的复用性。同时，Docker 镜像分层的设计还可以方便地管理和维护镜像。例如，在更新镜像时，只需要修改镜像的某个层，而不需要对整个镜像重新构建，从而节省了时间和资源。

### 2. Docker 镜像分层的优势是什么？⭐⭐⭐⭐

1. 减小镜像大小：因为每个层都是只读的，所以在创建新镜像时，只需要新增或修改一层即可，不会影响到已有的层，从而减小了镜像的大小。同时，不同的镜像可以共享相同的层，从而减少了重复的数据存储，进一步减小了镜像的大小。
2. 提高镜像的复用性：由于Docker镜像分层的设计，不同的镜像可以共享相同的层，这就使得镜像的复用性得到了极大地提高。例如，当多个容器需要使用同一份镜像时，它们可以共享相同的只读层，这样就可以节省存储空间，并且不需要重复下载和构建镜像。
3. 方便镜像的管理和维护：由于每个层都可以单独更新和管理，因此 Docker 镜像的管理和维护变得更加容易。例如，在更新镜像时，只需要修改镜像的某个层，而不需要对整个镜像重新构建，这样就可以节省时间和资源，并且降低出错的风险。
4. 提高镜像的构建效率：利用 Docker 镜像分层的特性，可以将常用的层缓存下来，从而减少重复的构建过程，加快镜像构建的速度。同时，通过多阶段构建的方式，将构建过程拆分成多个阶段，每个阶段都可以利用不同的Docker镜像分层，从而进一步提高构建速度。

### 3. Docker 镜像的分层是如何实现的？⭐⭐⭐⭐

Docker 镜像分层的实现是通过 UFS（Union File System）联合文件系统来实现的。 **联合文件系统（Union File System）是一种将多个文件系统挂载到同一目录下的技术，使得这些文件系统中的内容可以像一个文件系统一样被访问** 。在联合文件系统中，多个不同的文件系统以层次结构的形式被组织在一起，从而使得用户可以通过单一的挂载点来访问多个不同的文件系统。

在 Docker 中，每个镜像都是由多个只读层（镜像层）和一个可读写层（容器层）组成。Docker 通过 UFS 联合文件系统将这些只读层和可读写层合并在一起，形成一个联合文件系统。

### 4. 如何利用 Docker 镜像分层优化镜像构建过程？⭐⭐⭐

利用 Docker 镜像分层优化镜像构建过程可以从以下几个方面入手：

1. 利用缓存：在构建 Docker 镜像时，Docker 会利用缓存来避免重复的构建过程。如果某个镜像层已经被构建过，Docker 就可以直接从缓存中获取该层，从而加快构建速度。因此，为了利用缓存，我们应该尽量减少构建过程中的变化，例如在 Dockerfile 中将不经常修改的指令放在前面，将经常修改的指令放在后面。
2. 利用多阶段构建：Docker 从 17.05 版本开始支持多阶段构建。利用多阶段构建，可以将构建过程拆分成多个阶段，并在每个阶段中利用不同的 Docker 镜像分层，从而减少重复的构建过程。
3. 选择合适的基础镜像：选择合适的基础镜像可以减少构建过程中的变化，从而提高构建速度。通常情况下，我们应该选择官方的基础镜像，因为官方的基础镜像已经被优化过，同时也得到了广泛的测试和验证。
4. 减小镜像大小：减小镜像大小可以加快构建速度，同时也可以减少存储空间的占用。为了减小镜像大小，我们可以采用一些常用的优化技巧，例如将多个指令合并成一个、使用多阶段构建、删除无用文件和缓存等。

### 5. 镜像层是可写的吗？怎么实现可写⭐⭐⭐⭐

Docker 镜像层是只读的，这是为了保证镜像的不可变性，也就是说，一个镜像被创建之后，它的每一层都是只读的，不能被修改。这样可以保证每个容器都以相同的镜像层为基础，从而保证容器之间的环境一致性。

然而，在有些情况下，我们需要对容器进行一些修改，例如安装软件、修改配置文件等。此时，我们可以通过在容器层上创建一个新的可写层来实现这个目的。Docker 中的可写层也称为容器层（container layer）或工作层（working layer），它是在只读的镜像层之上创建的一个可写层。

 **当我们启动一个容器时，Docker 会在镜像层之上创建一个可写层，并将这个可写层挂载到容器的文件系统中** 。容器层中的所有修改都将保存在这个可写层中，而镜像层则保持不变。这样，即使多个容器都使用同一个镜像，它们之间也可以有不同的可写层。

### 6. Docker 中基础镜像的作用⭐⭐⭐⭐

Docker 中基础镜像是用来构建 Docker 镜像的基础，也是构建整个 Docker 镜像的起点。它是一个只读的文件系统，包含了一些基本的操作系统和软件组件，例如操作系统内核、文件系统、运行时环境、库文件、工具等。

使用基础镜像可以避免从头开始构建 Docker 镜像，从而节省时间和精力。基础镜像已经被优化过，并且得到了广泛的测试和验证，因此可以保证镜像的稳定性和可靠性。

### 7. 容器层删除文件时，文件本体会被删除吗？⭐⭐⭐⭐

当容器层中的文件被删除时，文件本体不会被删除，因为容器层是一个可写层，它是在只读的镜像层之上创建的一个可写层，容器层中的所有修改都将保存在这个可写层中，而镜像层则保持不变。因此，当容器中的文件被删除时，实际上是删除了容器层中的文件记录，而不是删除了镜像层中的文件本体。

### 8. centos 镜像几个 G，但是 docker centos 镜像才几百 M，这是为什么？⭐⭐⭐⭐

这是因为 CentOS 镜像是完整的操作系统镜像，包含了所有的软件包和文件，而 Docker 镜像则是基于操作系统的一层层的增量更新，每一层都只包含一个或几个操作，可以共用基础镜像，因此其大小较小。

### 9. 讲一下镜像的分层结构以及为什么要使用镜像的分层结构？⭐⭐⭐⭐

一个新的镜像其实是从基础镜像一层一层叠加生成的。每安装一个软件，dockerfile 中使用 RUM 命令，就会在现有镜像的基础上增加一层，这样一层一层的叠加最后构成整个镜像。

分层结构最大的一个好处就是：共享资源。比如：有多个镜像都从相同的基础镜像构建而来，那么只需在磁盘上保存一份基础镜像；同时内存中也只需加载一份基础镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。

### 10. 说说容器 Copy-on-Write(COW) 特性⭐⭐⭐⭐

容器 Copy-on-Write (COW) 特性是 Docker 中非常重要的一个特性。它的作用是让容器创建时尽可能地复用镜像层，从而节省存储空间并提高容器的创建速度。

当一个容器启动时， **Docker 会创建一个容器层作为容器的可写层，并将该容器层与镜像层进行联合挂载** 。在容器运行时，所有的写操作都会被记录到容器层中，而 **不会对镜像层进行任何修改** 。因此，如果多个容器都使用同一个镜像，它们会共享相同的镜像层，而容器层则会针对每个容器单独记录写入操作。这种方式可以避免重复复制相同的数据，从而提高存储效率，并且能够更快地启动新的容器。

 **当容器层中的文件被修改时，Docker 会使用 Copy-on-Write (COW) 技术来创建新的文件副本，而不是在原始镜像层上直接修改文件** 。这意味着对文件的修改不会影响其他容器或镜像的使用，同时也能够更好地支持多个容器同时使用同一个镜像的场景。

## 六、面试题

### 1. 什么是 Dockerfile？它有什么作用？⭐⭐⭐

Dockerfile 是一个包含用于构建 Docker 镜像的命令和指令的文本文件。它定义了镜像中包含的操作系统、应用程序、配置文件等组件，以及如何将它们组合在一起以创建可重复的 Docker 镜像。Dockerfile 的作用是提供一个自动化的镜像构建过程，通过在 Dockerfile 中定义的命令和参数，自动化地创建和配置 Docker 镜像，从而实现快速、可重复、可移植的应用部署。

### 2. Dockerfile 中的 FROM 命令的作用是什么？⭐⭐⭐

FROM 命令指定了用于构建 Docker 镜像的基础镜像。这是 Dockerfile 中最重要的命令之一，因为它确定了容器的基础操作系统和运行时环境。

### 3. 如何在 Dockerfile 中安装应用程序和依赖项？⭐⭐⭐

可以使用 RUN 命令在 Dockerfile 中安装应用程序和依赖项。RUN 命令允许在容器中运行任意的命令和脚本，例如在 Ubuntu 中使用 apt-get 安装软件包，在 Python 中使用 pip 安装 Python 包等。

### 4. 如何将本地文件复制到 Docker 镜像中？⭐⭐⭐

可以使用 COPY 命令将本地文件复制到 Docker 镜像中。COPY 命令可以将本地文件或目录复制到 Docker 镜像中的指定位置。

### 5. 如何在 Dockerfile 中设置环境变量？⭐⭐⭐

可以使用 ENV 命令在 Dockerfile 中设置环境变量。ENV 命令可以将一个或多个环境变量设置为指定的值。

### 6. 如何在 Dockerfile 中暴露端口？⭐⭐⭐

可以使用 EXPOSE 命令在 Dockerfile 中暴露容器的端口。EXPOSE 命令告诉 Docker，容器将监听指定的端口，但并不会自动将它们映射到主机上的端口。

### 7. 如何在 Dockerfile 中使用多条命令来构建一个镜像？⭐⭐⭐

可以在 Dockerfile 中使用多个 RUN 命令来构建一个镜像。每个 RUN 命令将在容器中执行一个命令或脚本，从而逐步构建镜像。

 **需要注意的是，每个 RUN 命令都会在镜像中创建一个新的中间层。如果需要多次执行命令，可以将多个命令组合到一起，以减少镜像的层数** 。例如，可以使用以下命令来替代上面的 Dockerfile：

```text
FROM ubuntu:18.04

RUN apt-get update && \
    apt-get install -y \
    python3 \
    git
```

### 8. Dockerfile 中的 CMD 和 ENTRYPOINT 命令有什么区别？⭐⭐⭐

1. CMD 命令定义了容器启动时默认执行的命令，如果在运行容器时指定了其他命令，则会覆盖 CMD 命令。CMD 命令可以在 Dockerfile 文件中多次出现，但只有最后一个会生效。如果 CMD 命令需要参数，可以在命令后面指定，例如 `CMD ["executable", "param1", "param2"]`。
2. ENTRYPOINT 命令也定义了容器启动时要执行的命令，但是不会被覆盖。ENTRYPOINT 命令也可以在 Dockerfile 文件中多次出现，但只有最后一个会生效。如果需要在运行容器时指定其他命令，可以在 ENTRYPOINT 命令后面使用 CMD 命令提供参数，例如 `ENTRYPOINT ["executable", "param1"]` 和 `CMD ["param2"]`。

### 9. Dockerfile 中的 COPY 和 ADD 命令有什么区别？⭐⭐⭐

在 Dockerfile 中，COPY 和 ADD 命令都可以用于将本地文件或目录复制到 Docker 镜像中，但是它们在一些细节上有所不同：

1. COPY 命令只能复制本地文件或目录，而 ADD 命令支持复制本地文件或目录，还可以从 URL 或 tar 归档文件中提取文件。
2. ADD 命令在复制文件时还支持自动解压缩 tar 归档文件，这使得 ADD 命令更加灵活，但也增加了镜像大小。
3. ADD 命令还支持在复制文件时进行权限更改、归档校验和和文件的远程复制等功能，但这些功能可能会增加 Docker 镜像构建的时间和复杂性。
4. COPY 命令比 ADD 命令更加简单和透明，它不会执行任何自动化操作，因此在大多数情况下，COPY 命令比 ADD 命令更受推荐。

### 10. Dockerfile 常用命令⭐⭐⭐

* FROM：指定基础镜像，格式为 FROM image:tag。
* RUN：在容器中执行命令，格式为 RUN command。
* COPY：将本地文件或目录复制到容器中，格式为 COPY source destination。
* ADD：将本地文件或目录复制到容器中，并支持从URL或tar归档文件中提取文件，格式为 ADD source destination。
* WORKDIR：设置工作目录，格式为 WORKDIR path。
* ENV：设置环境变量，格式为 ENV key=value。
* EXPOSE：指定容器暴露的端口，格式为 EXPOSE port。
* CMD：指定容器启动时的默认命令和参数，格式为 CMD command。
* ENTRYPOINT：指定容器启动时要运行的可执行文件或脚本，格式为 ENTRYPOINT command。

### 11. 说说 Docker Compose 的作用⭐⭐⭐

Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。它允许用户在一个 YAML 文件中定义多个容器以及它们之间的关系和依赖关系，以便一次性启动、停止和重建整个应用程序。Docker Compose 的作用如下：

1. 简化应用程序的部署：使用 Docker Compose 可以轻松地将多个容器打包在一起，构建出一个完整的应用程序，简化了部署和管理的工作。
2. 定义容器间的关系：在 Docker Compose 文件中，可以定义多个容器之间的关系，如依赖关系、网络连接、数据卷挂载等，使得应用程序的配置更加灵活。
3. 避免手动配置：使用 Docker Compose 可以避免手动配置各个容器之间的关系和依赖，减少出错的机会。
4. 快速构建和部署：使用 Docker Compose 可以快速构建和部署整个应用程序，从而缩短了开发和测试的周期。
5. 提高可移植性：使用 Docker Compose 可以在不同的环境中部署应用程序，提高了应用程序的可移植性，也方便了开发人员在不同的开发环境中工作。

### 12. 简单描述一下 Dockerfile 的整个构建镜像过程⭐⭐⭐

Dockerfile 是一个文本文件，其中包含了一系列用于构建 Docker 镜像的指令，通过执行 docker build 命令，Docker 会按照 Dockerfile 中的指令逐层构建镜像。整个构建镜像的过程可以简单地分为以下几个步骤：

1. 创建一个新的临时容器：Docker 会基于指定的基础镜像启动一个新的容器。
2. 执行 Dockerfile 中的指令：Docker 会依次执行 Dockerfile 中的指令，每个指令都会在当前的容器中创建一个新的临时镜像层。
3. 对比并提交镜像层：在每个指令执行完成后，Docker 会将当前容器与上一层镜像进行比较，将容器中的差异部分提交为一个新的镜像层。
4. 重复执行步骤 2 和 3，直到所有指令都执行完成。
5. 生成最终镜像：当 Dockerfile 中的所有指令都执行完成后，Docker 会将最终生成的镜像层打包为一个完整的镜像，并将其保存到本地的镜像仓库中。

## 七、面试题

### 1. Docker 网络类型⭐⭐⭐

1. None网络：容器没有网络连接，适用于一些特殊的场景，如容器只需要本地访问或者与其他容器通过共享数据卷进行通信。
2. Container网络：与另一个运行中的容器共享Network Namespace。
3. Host网络：使用宿主机的网络栈直接暴露容器的端口，容器和宿主机共享同一个IP地址，容器的网络性能会比较好，但会受到宿主机网络性能的限制。
4. Bridge网络：这是Docker默认使用的网络类型，它会在Docker宿主机上创建一个虚拟的网络桥接器，用于连接所有容器。
5. Macvlan网络：用于将容器连接到物理网络，每个容器都有一个唯一的MAC地址，可以直接通过宿主机网络与物理网络进行通信。
6. Overlay Network 基于 VXLAN 技术实现，它将不同主机上的容器连接到一个虚拟网络中，使得这些容器可以相互通信和协同工作。

| None            | 不为容器配置任何网络功能，没有网络 --net=none                          |
| --------------- | ---------------------------------------------------------------------- |
| Container       | 与另一个运行中的容器共享Network Namespace，--net=container:containerID |
| Host            | 与主机共享Network Namespace，--net=host                                |
| Bridge          | Docker设计的NAT网络模型（默认类型）                                    |
| Macvlan         | 每个容器都有一个唯一的MAC地址，以此进行物理网络通信                    |
| Overlay Network | 将不同主机上的容器连接到一个虚拟网络中                                 |

### 2. 说说 Host 网络，优缺点是什么⭐⭐⭐

Host 网络是 Docker 支持的一种网络模式，它可以让容器直接使用宿主机的网络栈，从而避免了网络地址转换 (NAT) 的开销和性能损失。

Host 网络的优点包括：

1. 性能更好：由于容器直接使用宿主机的网络栈，因此无需进行端口映射和数据包转发，网络性能更好，延迟更低。

2 .网络隔离更弱：容器与宿主机共享网络栈，因此它们之间的网络隔离更弱，容器可以直接访问宿主机上的网络和端口。

Host 网络的缺点包括：

1. 安全性较差：容器与宿主机共享网络栈，容器之间的网络隔离更弱，因此容器之间的网络攻击风险更高。
2. 可扩展性较差：Host 网络模式不支持容器的自动扩展，因为每个容器都需要占用宿主机的端口资源，因此会对宿主机造成一定的负载压力。

### 3. 说说 Bridge 网络，优缺点是什么⭐⭐⭐

Bridge 网络是 Docker 中最常用的网络模式之一，它将 Docker 容器连接到一个 Docker 管理的虚拟网络中。每个容器可以分配一个 IP 地址，并且可以通过容器名称进行相互访问。Bridge 网络在 Docker 中是默认的网络模式。

Bridge 网络的优点包括：

1. 安全性好：Bridge 网络可以隔离容器之间的网络，保证容器之间的通信不会受到其他容器的干扰。每个容器可以分配一个独立的 IP 地址，从而保证容器之间的网络隔离。
2. 管理和扩展性好：Bridge 网络模式支持容器的自动扩展和负载均衡，可以将容器部署在不同的主机上，并通过 Docker Swarm 进行管理和控制。同时，Bridge 网络还支持自定义网络配置和插件，可以根据实际需求进行灵活的网络管理和扩展。
3. 易于使用：Bridge 网络是 Docker 的默认网络模式，可以直接使用 Docker 命令进行创建和管理。容器之间可以通过容器名称进行访问，无需进行端口映射和地址转换。

Bridge 网络的缺点包括：

1. 性能略差：Bridge 网络需要进行端口映射和地址转换，会对网络性能产生一定的影响。在高并发、大流量的应用场景下，可能会影响应用程序的性能。
2. 容器之间的网络隔离性相对 Host 网络较好。

### 4. Docker 网络类型中安全性最高的⭐⭐

None网络：容器没有网络连接，安全性最高。但是不实用。

### 5. Docker 如何保证容器数据持久化⭐⭐⭐

Docker 提供了以下几种方式：

1. 数据卷（Volume）：数据卷是 Docker 中最常用的数据持久化方式之一。数据卷是一个可独立于容器之外存在的目录（独立存储卷），可以将数据卷挂载到容器中，从而使容器能够访问该目录中的数据。数据卷通常存储在主机上的文件系统中，因此即使容器被删除或重新创建，数据卷中的数据仍然可以保留。
2. Docker 卷插件（Volume Plugin）：Docker 卷插件是一种扩展 Docker 存储功能的方式，可以通过插件机制，将 Docker 卷连接到外部存储系统，如云存储、分布式文件系统等。

## 八、面试题

### 1. 说说你对容器实现原理的理解⭐⭐⭐

容器其实是一种特殊的进程，不过这个进程实现了隔离和资源限制。

而容器技术的实现原理在于通过限制和调整进程的动态表现，为其 **创建一个明确的“边界”** 。在 Docker 等大多数 Linux 容器中， **Cgroups 技术是制造限制的主要手段，而 Namespace 技术则是调整进程视图的主要方式** 。

Linux 操作系统提供了  **PID、Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行隔离操作** 。

又提供了 **Linux Cgroups（Linux Control Group） 用来为进程设置资源限制。其主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等** 。

通过 Linux 的这两种技术，就实现了普通进程的隔离与资源限制，这就是容器的本质。

### 2. 说说 Linux Namespace技术⭐⭐⭐

Linux Namespace 是 Linux 内核提供的一种机制， **用于将系统资源隔离到不同的命名空间中，每个命名空间都拥有独立的资源视图** 。这种隔离机制使得不同进程可以在相同的系统上独立运行，不会相互影响。

Linux 操作系统提供了  **PID、Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行隔离操作** 。

比如 Linux 使用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，这样创建的进程就处于一个新的 PID Namespace。

### 3. 说说 Linux Cgroups 技术⭐⭐⭐

Linux Cgroups（Control groups）是一种内核级别的机制，用于限制和管理进程、任务或者用户组的系统资源使用。Cgroups 可以在不同的层次结构中对系统资源进行分类，每个分类可以设置自己的资源限制、优先级和控制策略。 **其主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等** 。

在 `/sys/fs/cgroup` 目录下，有许多名为 cpuset、cpu 和 memory 的子目录，这些目录被称为子系统，表示可由 Cgroups 限制的资源种类。比如我们可以在这些子系统中创建新目录，目录下自动生成该子系统对应的资源限制文件，通过配置这些文件，我们就可以实现资源配置了。

## 九、面试题

### 1. 说说容器运行时⭐⭐⭐

容器运行时是一种用于管理和运行容器的软件工具。它负责解析容器镜像、创建和管理容器的生命周期、以及与底层操作系统进行交互等任务。

容器运行时通常与容器编排工具（例如 Kubernetes）一起使用，以提供一种可伸缩、可靠和高效的容器化解决方案。容器运行时可以支持多种容器格式和操作系统，例如 Docker、rkt、CRI-O、Kata Containers 等。

### 2. Containerd 常用命令⭐⭐⭐

* `ctr image pull <image>`：拉取指定的镜像
* `ctr image ls`：列出本地所有镜像
* `ctr image rm <image>`：删除本地的指定镜像
* `ctr container create <container>`：创建一个容器
* `ctr container start <container>`：启动指定容器
* `ctr container ls`：列出所有正在运行的容器
* `ctr container stop <container>`：停止指定容器
* `ctr container rm <container>`：删除指定容器
* `ctr tasks ls`：列出所有正在运行的任务

### 3. Containerd 和 Docker 的区别⭐⭐⭐

1. 定位不同：Docker 早期被认为是一种容器技术，而现在已经发展成为一个生态系统，提供了包括构建、发布、部署、运行和管理容器的一系列工具和服务；而 Containerd 则更专注于容器运行时，它是一个轻量的容器运行时，为 Kubernetes 等容器编排工具提供了底层支持。
2. 架构不同：Docker 是一个完整的容器解决方案，它包括 Docker 引擎、Docker Registry 和 Docker Compose 等多个组件；而 Containerd 则是一个容器运行时，它可以通过 gRPC API 与外部系统交互，并通过不同的插件（如 runc）提供容器运行时服务。
3. 功能不同：Docker 提供了丰富的功能，如构建镜像、发布镜像、容器编排等等；而 Containerd 只提供了容器的运行时服务，例如容器的生命周期管理、容器文件系统挂载等。

新老版本的 Kubernetes 调用链如图：

![](https://picx.zhimg.com/v2-5df2b40d65c04fe75b89d7aedc9075d1_1440w.jpg)

## 十、面试题

### 1. Kubernetes 了解吗？⭐⭐⭐

Kubernetes 是一个开源的容器编排平台，它能够自动化地部署、扩展和管理容器化的应用程序。Kubernetes 可以帮助用户轻松地管理多个容器化应用程序，使得应用程序可以更加高效、可靠和可扩展。包含了 Pod、Department、StatefulSet、Job、Configmap、Secret 等资源。同时也包含了 kube-apiserver、kube-controller-manager、kube-scheduler、kubelet、kube-proxy 等核心组件。

### 2. Kubernetes 的优势⭐⭐⭐

Kubernetes 有很多优势，以下是其中的一些：

1. 自动化：Kubernetes 可以自动化地管理应用程序的部署、扩展和维护，极大地减轻了开发人员和运维人员的工作负担。
2. 可靠性：Kubernetes 具有高可用性和自动故障恢复功能，如果一个节点或 Pod 失败，Kubernetes 会自动重新调度该节点或 Pod，以确保应用程序的可靠性。
3. 可扩展性：Kubernetes 可以自动扩展应用程序的容量，以满足高流量的需求，并在流量降低时缩减容量，以节省成本。
4. 弹性和灵活性：Kubernetes 支持多种容器运行时和云平台，可以在任何环境中运行容器化应用程序，并能够适应各种需求和变化。
5. 生态系统：Kubernetes 有庞大的生态系统，提供了许多插件和工具，以扩展其功能，并与其他工具和服务进行集成。
6. 安全性：Kubernetes 提供了多种安全机制，例如容器隔离、访问控制、加密等，以确保应用程序和集群的安全性。

### 3. 简要说说 Kubernetes 的核心组件⭐⭐⭐

Kubernetes 的核心组件包括以下几个：

1. kube-apiserver：Kubernetes API 服务器，提供 Kubernetes API 的接口，处理对集群的所有操作请求。
2. etcd：分布式键值存储系统，用于存储 Kubernetes 集群的配置信息和状态信息。
3. kube-scheduler：Kubernetes 调度器，负责将 Pod 调度到集群中的节点上运行，并根据节点的资源情况和 Pod 的需求进行智能调度。
4. kube-controller-manager：Kubernetes 控制器管理器，负责监控集群中的各种资源对象，并根据配置的控制器逻辑进行自动化管理和调节。
5. kubelet：Kubernetes 节点代理，负责在节点上运行容器，并与 kube-apiserver 通信，以接收 Pod 和容器的配置信息。
6. kube-proxy：Kubernetes 服务代理，负责实现 Kubernetes Service 的负载均衡和访问控制，使得应用程序可以通过虚拟 IP 地址进行访问。

### 4. 说说 Kubernetes 常用命令⭐⭐⭐

1. kubectl get：获取 Kubernetes 集群中的资源对象的信息，例如获取所有的 Pod、Service、Deployment 等。
2. kubectl create：在 Kubernetes 集群中创建新的资源对象，例如创建一个新的 Pod、Service、Deployment 等。
3. kubectl apply：应用配置文件，可以更新或创建一个资源对象，并保持状态一致。
4. kubectl delete：删除 Kubernetes 集群中的资源对象，例如删除一个 Pod、Service、Deployment 等。
5. kubectl describe：查看 Kubernetes 集群中资源对象的详细信息，例如查看 Pod 的容器日志、IP 地址等。
6. kubectl logs：查看 Pod 或容器的日志信息。
7. kubectl exec：在 Pod 中的容器内执行命令。

### 5. Kubernetes 中有哪些常用概念，说一说⭐⭐⭐

以下是一些常见的 Kubernetes 概念：

* Pod：Pod 是 Kubernetes 中最小的调度单元，它包含一个或多个相关的容器，这些容器共享相同的网络命名空间和数据卷，并且可以通过 localhost 相互通信。
* Service：Service 是一种逻辑组件，用于公开一个或多个 Pod，提供一个稳定的 DNS 名称和 IP 地址，以及负载平衡和服务发现功能。
* Deployment：Deployment 是一种控制器，用于管理 Pod 的副本数量和版本控制，支持滚动升级、回滚、暂停和恢复等操作。
* ReplicaSet：ReplicaSet 是 Deployment 的底层实现，它确保在任何时间点都有指定数量的 Pod 在运行，并可以自动扩展和缩小 Pod 的数量。
* Namespace：Namespace 是一种逻辑隔离机制，用于将集群划分为多个虚拟集群，每个 Namespace 中的对象都可以使用唯一的名称进行标识。
* ConfigMap：ConfigMap 是一种 Kubernetes 对象，用于存储配置信息，包括环境变量、命令行参数、配置文件等。
* Secret：Secret 是一种 Kubernetes 对象，用于存储敏感信息，如密码、API 密钥等。
* Volume：Volume 是一种抽象的文件系统，它可以在 Pod 和容器之间共享数据，并且可以支持多种类型的存储介质，包括本地存储、云存储等。
* StatefulSet：StatefulSet 是一种控制器，用于管理有状态的应用程序，如数据库、缓存等，支持有序部署、有序删除、有序扩展等操作。

### 6. Kubernetes 如何实现集群管理⭐⭐⭐

有三个 Master 节点，共同组成了 **管理面集群** ，三个 Master 就是考虑到了高可靠性、容灾。三个 Master 节点通过 Load Balancer 实现负载均衡（负载均衡 Load Balancer 是一种分布式系统架构中常用的技术，用于将访问流量分发到多个服务器上，以实现高可用、高性能、高扩展性的网络服务。）

三个 Master 节点组成 **管理面集群** ，之所以称之为管理面，顾名思义，管理面是不跑业务的，业务要运行在 **数据面节点** ，即 **Node 或 Worker** 上，Master 是管理 Node 的，注意这一层关系，即 **主从关系** 。管理面只运行 Kubernetes 核心组件，如 kube-apiserver、etcd、kube-scheduler、kube-controller-manager。

### 7. 简述 Kubernetes 中什么是 Minikube、Kubectl、Kubelet?⭐⭐⭐

1. Minikube：是 Kubernetes 的一个轻量级的单节点版本，可在本地电脑上快速搭建一个 Kubernetes 环境，方便开发人员进行本地开发和测试。
2. Kubectl：是 Kubernetes 的命令行工具，用于管理 Kubernetes 集群和应用程序，包括创建、更新、删除 Kubernetes 对象，查看 Kubernetes 对象状态等。
3. Kubelet：是 Kubernetes 的一个核心组件，主要用于管理和控制运行在节点上的 Pod，它会负责启动和停止容器，并监控 Pod 的运行状态。Kubelet 还会与 Kubernetes 的其它组件进行通信，如 API Server 和 Scheduler，以保证节点上的容器可以正常运行。

### 8. 简述 Kubernetes 和 Docker 的关系?⭐⭐⭐

Kubernetes 和 Docker 是两个不同的软件，但它们通常被一起使用。Docker 是一种容器化平台，可以让开发人员在容器中构建、打包、分发和运行应用程序，而 Kubernetes 则是一种容器编排平台，可以自动管理和部署容器化应用程序。

Kubernetes 利用 Docker 提供的容器化技术来打包应用程序，并在集群中运行它们。Kubernetes 提供了一些有用的功能，如服务发现、负载均衡、自动扩展和滚动更新，使得管理和运行容器化应用程序变得更加容易和高效。 **可以说，Docker 为 Kubernetes 提供了容器化技术，而 Kubernetes 则提供了容器编排和管理能力** 。

## 十一、面试题

### 1. 什么是 Kubernetes 中的 Pod？⭐⭐⭐⭐

Pod 是 Kubernetes 中 **最小的可调度和可部署的单元** ，它是一组容器的集合，它们共享网络和存储资源，并在同一节点上运行。Pod 可以包含一个或多个容器，并且它们共享相同的网络命名空间、IP 地址和存储卷。Pod 被用于运行一个或多个紧密相关的容器，并提供了一个独立的环境来运行它们。

把 Pod 看成传统环境里的“机器”、把容器看作是运行在这个“机器”里的“用户程序”。

### 2. 为什么在 Kubernetes 中使用 Pod？⭐⭐⭐⭐

Pod 提供了一种在容器化环境中运行多个容器的方式，这些容器之间可以共享资源、共享网络和共享存储卷。Pod 允许将一组紧密相关的容器放置在同一节点上，并通过本地的进程间通信（IPC）和网络命名空间共享数据。Pod 还可以一起调度和管理容器的生命周期，从而简化了容器化应用程序的部署和管理。

### 3. 你知道 Pause 容器吗？有什么作用？⭐⭐⭐⭐

在 Kubernetes 中，Pause 容器是 Pod 中的一个特殊容器，用于实现 Pod 内容器的网络和存储资源的共享。Pause 容器是一个轻量级的容器，没有实际的应用进程运行在其中，其主要作用是创建一个网络命名空间和一个存储卷，并在 Pod 中的其他容器之间共享这些资源。Pause 容器由 Kubernetes 自动创建并管理。

### 4. 说说静态 Pod，怎么创建和删除？⭐⭐⭐⭐

 **静态 Pod 是一种不由 Kubernetes 控制平面管理的 Pod** ，它是通过 **直接在节点上创建 Pod 定义文件来定义和管理的** 。与动态 Pod 相比，静态 Pod 不是由 Kubernetes 控制器（如Deployment或ReplicaSet）创建和管理的，而是 **由节点上的 kubelet 直接创建和管理的** 。 **这意味着静态 Pod 的生命周期不受 Kubernetes 控制器的管理，而是与节点的生命周期绑定在一起** 。

静态 Pod 的定义文件通常存储在节点的本地文件系统上，例如存储在 `/etc/kubernetes/manifests` 目录中， **kubelet 会在启动时扫描该目录，查找定义文件并创建相应的 Pod** 。 **如果 Pod 的定义文件发生变化，kubelet 会自动检测并更新 Pod 的配置** 。当从 `/etc/kubernetes/manifests` 目录中删除定义文件时，就是删除静态 Pod。

### 5. Pod 中容器共享网络命名空间是怎么实现的？⭐⭐⭐⭐

在 Kubernetes 的 Pod 中，容器共享网络命名空间是通过容器之间运行在同一个 Linux 命名空间中实现的。借助 Docker 的 Container 网络类型，在 Pod 中，业务容器都是与 Pause 容器共享 Network Namespace。这样交互性能更好，通信延迟更短。

### 6. Kubernetes 管理面核心组件是静态 Pod 还是动态 Pod？⭐⭐⭐⭐

Kubernetes 管理面核心组件（etcd、kube-apiserver、kube-controller-manager、kube-scheduler）是静态 Pod。

### 7. 什么是 Namespace，作用是什么？⭐⭐⭐⭐

在 Kubernetes 中，Namespace 是一种资源类型， **用于将集群内的资源分组和隔离，以便多个团队或项目可以在同一个集群上运行它们自己的应用程序，并保持相互独立。Namespace 可以看作是一个逻辑分区或虚拟集群，用于管理不同应用程序的资源** 。

Namespace 提供以下功能：

* 隔离资源：使用 Namespace 可以将不同的资源划分到不同的命名空间中，以便将不同应用程序或环境之间的资源隔离开来，防止资源的冲突或互相干扰。
* 访问控制：通过 Namespace 可以实现资源访问控制，将不同的应用程序或团队之间的访问控制隔离开来，提高安全性。
* 资源配额：使用 Namespace 可以为不同的应用程序或团队分配资源配额，避免资源浪费和竞争。
* 多租户：Namespace 可以使 Kubernetes 集群支持多租户模式，将集群资源分配给不同的租户，提高资源利用率。
* 环境隔离：Namespace 可以使不同的应用程序或环境之间进行隔离，例如将生产环境和测试环境分别放在不同的 Namespace 中，防止测试环境影响生产环境。

### 8. Pod 的原理是什么？⭐⭐⭐⭐

在微服务的概念里，一个容器会被设计为运行一个进程。

这样，由于不能将多个进程聚集在同一个单独的容器中，所以需要一种更高级的结构将容器绑定在一起，并将它们作为一个单元进行管理，同时将 Pod 作为一个外壳，为内部容器提供各种资源，再定义紧密协作的容器，这就是 Pod 产生的深刻原因。

### 9. Pod 里有哪些共享资源⭐⭐⭐

1. 网络命名空间：在同一个 Pod 中的容器共享同一个网络命名空间，它们可以使用相同的网络接口和 IP 地址。
2. IPC 命名空间：在同一个 Pod 中的容器共享 IPC 命名空间，它们可以通过 System V IPC 和 POSIX message queues 进行通信。
3. PID 命名空间：在同一个 Pod 中的容器共享 PID 命名空间，它们可以看到同样的进程和 PID。
4. Volume：在同一个 Pod 中的容器可以共享同一个 Volume，它们可以共享相同的数据卷，并且可以通过 Volume 进行通信。
5. Linux namespace：在同一个 Pod 中的容器可以共享 Linux namespace，比如 mount namespace、user namespace、uts namespace 和 cgroup namespace。

## 十二、面试题

### 1. Kubernetes Volume 与 Docker Volume 有何不同？⭐⭐

1. 实现方式不同：Docker Volume 是在宿主机上创建一个目录，然后将其挂载到容器中，而 Kubernetes Volume 是在容器运行时自动创建并挂载 Volume。
2. 层级不同：Docker 中的 Volume 针对容器而言。Kubernetes 中的 Volume 是针对 Pod 而言的，而不是针对容器而言的。因此，在 Kubernetes 中，Volume 可以被多个容器共享，不同容器之间可以通过 Volume 共享数据。
3. 生命周期不同：Docker 中的 Volume 的生命周期跟随容器；Kubernetes 中的 Volume 的生命周期跟随 Pod。

### 2. Kubernetes 中 Volume 的类型⭐⭐⭐

Kubernetes 目前支持的 Volume 类型包括 Kubernetes 的内部资源对象类型、开源共享存储类型、存储厂商提供的硬件存储设备和公有云提供的存储设备等。

**1.Kubernetes 的内部资源对象类型**

* ConfigMap：这种方式允许将配置文件或其他非 Secret 以 Volume 形式共享到 Pod 中的一个或多个容器。
* Secret：这种方式允许将 Secret 以 Volume 形式共享到 Pod 中的一个或多个容器。
* DownwardAPI：Pod 或 container 的元数据信息。

**2.Kubernetes 管理的宿主机本地存储类型**

* EmptyDir Volume：这是最简单的方式，它创建一个空目录，并将它挂载到每个容器中。容器可以读写此目录中的文件。但是，当 Pod 重新启动或在另一个节点上重新创建时，该目录将被清空。
* HostPath Volume：这种方式将 Pod 的本地文件系统目录直接挂载到容器中。这允许多个容器共享同一文件系统，但它不适用于多个节点之间的容器共享。

**3.持久化存储（PV）和网络共享存储类型**

* NFS存储：NFS(Network File System) 是一种分布式文件系统，可以实现多台计算机之间的文件共享，是 Kubernetes 中常用的一种网络共享存储类型。
* iSCSI存储：iSCSI(Internet Small Computer System Interface) 是一种基于 IP 网络的存储协议，可以将远程的存储设备挂载到本地计算机上，实现数据的访问和共享。Kubernetes 支持 iSCSI 存储的挂载。
* Cinder存储：Cinder 是 OpenStack 提供的一种块存储服务，可以将存储设备挂载到虚拟机上，实现数据的持久化存储。Kubernetes 支持 Cinder 存储的挂载。

**4.存储厂商提供的硬件存储设备**

* **StorageOS** ：StorageOS 提供的存储设备
* **Vsphere Volume** ：VMWare 提供的存储系统

**5.公有云提供的存储设备**

* AWS EBS存储：AWS EBS(Elastic Block Store) 是亚马逊提供的一种云存储服务，可以将存储设备挂载到云服务器上，实现数据的持久化存储。Kubernetes 支持 AWS EBS 存储的挂载。
* Azure Disk存储：Azure Disk 是微软提供的一种云存储服务，可以将存储设备挂载到云服务器上，实现数据的持久化存储。Kubernetes 支持 Azure Disk 存储的挂载。

### 3. 说说 ConfigMap⭐⭐⭐⭐

ConfigMap 是 Kubernetes 中的一种资源对象，用于存储应用程序的**配置数据，例如环境变量、命令行参数、配置文件**等。它可以将配置数据与应用程序分离，从而使得应用程序更加灵活和可配置化。

在 Kubernetes 中，ConfigMap 是通过**键值对**的方式存储数据的。可以将多个键值对组合成一个 ConfigMap 对象，然后将其挂载到 Pod 中的容器中，以便容器可以使用其中的配置数据。

ConfigMap 可以在 Pod 中通过环境变量、命令行参数或者 Volume 的形式使用，以满足不同的应用场景需求。

### 4. 说说 Secret⭐⭐⭐⭐

Kubernetes 中的 Secret 是一种用于存储敏感数据的对象，例如 API 访问令牌、密码、SSH 密钥等，它们可以被安全地传递给容器中的应用程序。Secret 可以在 Pod 中被挂载为文件或环境变量，并且在使用时会被自动解密。

### 5. EmptyDir Volume 与 HostPath Volume 的区别⭐⭐⭐⭐

1. 位置不同：EmptyDir Volume 放在 Pod 所在的节点的临时目录中，而 HostPath Volume 放在宿主机的本地目录中。
2. 生命周期不同：EmptyDir Volume 的生命周期与 Pod 相关联，当 Pod 被删除时，EmptyDir Volume 也会被删除，而 HostPath Volume 的生命周期可以超出 Pod 的生命周期，也就是说即使 Pod 被删除，HostPath Volume 中的数据仍然可以被保留。
3. 安全性不同：由于 EmptyDir Volume 存储在节点上的本地存储中，因此不能保证数据的安全性，例如当节点故障时，EmptyDir Volume 中的数据可能会丢失，而 HostPath Volume 存储在宿主机的本地存储中，因此可以使用宿主机上的文件系统安全特性来保护数据。
4. 适用场景不同：EmptyDir Volume 通常用于存储临时文件或缓存数据等临时数据，例如：用于存储应用程序的日志文件、临时文件、缓存数据；HostPath Volume 适合需要文件持久化的场景。

### 6. EmptyDir Volume 与 HostPath Volume 各自的优点和缺点⭐⭐⭐⭐

EmptyDir Volume：优点：

1. 创建 EmptyDir Volume 非常简单，无需额外的配置。
2. 容器之间可以共享 EmptyDir Volume 中的数据，方便多个容器之间的数据传递。
3. EmptyDir Volume 的数据存储在 Node 节点的本地存储中，读写速度较快。

缺点：

1. 如果 Node 节点上的 Pod 意外终止，数据将会丢失。
2. EmptyDir Volume 的存储空间是有限的，当 Node 节点的存储空间被用尽时，Pod 将无法启动。

HostPath Volume：优点：

1. HostPath Volume 可以直接挂载 Node 节点上的文件或目录，无需额外的数据传输和存储。
2. HostPath Volume 的数据不会因为 Pod 意外终止而丢失，可以在下一次 Pod 启动时仍然保留。

缺点：

1. HostPath Volume 只能挂载单个 Node 节点上的文件或目录，不能实现多个 Pod 之间的数据共享。
2. HostPath Volume 的权限受限于宿主机上的文件系统，如果宿主机上的文件系统权限发生变化，可能会影响到 Pod 的运行。
3. 如果多个 Pod 使用同一个 HostPath Volume，可能会出现资源冲突问题。

### 7. 说一下 Downward API⭐⭐⭐⭐

Kubernetes Downward API 是一种 Kubernetes API，它允许容器访问其自身的元数据和环境变量，以及与 Pod 相关的元数据。通过 Downward API，容器可以获取 Pod 名称、命名空间、IP 地址等元数据，还可以获取 Pod 的标签、注释等信息。

需要注意的是，Downward API 只能访问与当前容器或 Pod 相关的元数据，不能访问其他容器或 Pod 的元数据。此外，Downward API 暴露的信息通常是只读的，不能用于修改容器或 Pod 的状态。

### 8. HostPath Volume 中 Directory 和 DirectoryOrCreate 的区别⭐⭐⭐

HostPath Volume 的 type 参数用于指定要挂载的文件系统类型：

* Directory：path指定的目录，需要手动创建。若不存在，挂载失败
* DirectoryOrCreate：如果指定的目录不存在，则创建它。

### 9. Pod 为什么要使用 Volume，如何使用？⭐⭐⭐

存储是必不可少的，对于服务运行产生的日志、数据，必须有一个地方进行保存，但是我们的容器每一次重启都是“ **恢复到出厂设置** ”，这样容器产生的所有数据都会丢失。因此 Kubernetes 必须要解决 Pod **持久化存储**问题。

要使用 Volume，需要通过 `.spec.volumes` 字段指定为 Pod 提供的卷，以及使用 `.spec.containers.volumeMounts` 字段指定卷挂载的目录。

## 十三、面试题

### 1. 说说 Pod 的生命周期，Pod 有几种状态⭐⭐⭐⭐

Pod 的生命周期包括以下几个阶段：

* Pending（等待）：Pod 被创建后，它将进入等待状态，等待 Kubernetes 调度器将它调度到一个节点上运行。在此阶段，Pod 可能会经历调度、镜像拉取、网络配置等过程。
* Running（运行中）：当 Kubernetes 将 Pod 调度到节点上并且容器开始运行时，Pod 就进入了 Running 阶段。在此阶段，Pod 中的容器可以相互通信，也可以访问共享的存储卷。
* Succeeded（成功）：当 Pod 中的容器成功完成它们的任务并退出时，Pod 就会进入 Succeeded 阶段。在此阶段，Pod 中的所有容器都已经停止运行。
* Failed（失败）：当 Pod 中的容器因为某种原因失败并退出时，Pod 就会进入 Failed 阶段。在此阶段，Pod 中的一个或多个容器可能已经停止运行，而其他容器可能还在继续运行。
* Unknown（未知）：如果 Kubernetes 无法获取 Pod 的状态信息，或者 Pod 所在的节点无法连接到 Kubernetes 控制平面，则 Pod 将进入 Unknown 阶段。

### 2. 说说 Pod 的重启策略⭐⭐⭐⭐

Kubernetes 提供了多种重启策略，包括：

* Always：无论何时，Pod 都会被重启。这是默认的重启策略。
* OnFailure：只有在容器以非 0 状态退出时才会重启 Pod。
* Never：Pod 不会被重启。

另外，Kubernetes 还提供了一些与重启策略相关的参数，可以进一步定义 Pod 的行为，包括：

* restartPolicy：指定重启策略，可选值为 Always、OnFailure 和 Never。
* terminationGracePeriodSeconds：指定 Pod 关闭时的等待时间。在该时间内，Kubernetes 会向容器发送 SIGTERM 信号，等待容器停止。如果在该时间内容器没有停止，Kubernetes 会向容器发送 SIGKILL 信号，强制停止容器。
* activeDeadlineSeconds：指定 Pod 运行的最大时间。如果超过该时间，Kubernetes 会强制删除该 Pod。
* backoffLimit：指定在容器启动失败时的重试次数。

### 3. Kubernetes 有几种探针⭐⭐⭐⭐

1. Liveness Probe：用于检测容器是否处于活动状态。如果 Liveness Probe 探测失败，则 Kubernetes 认为容器已经死亡，将会自动重启容器。可以使用 HTTP 接口、TCP 接口、命令行等方式进行探测。
2. Readiness Probe：用于检测容器是否已经准备好接受网络流量。如果 Readiness Probe 探测失败，则 Kubernetes 认为容器尚未准备好，将 Pod 移出 Endpoint，不会将网络流量转发到该容器。可以使用 HTTP 接口、TCP 接口、命令行等方式进行探测。
3. Startup Probe：用于检测容器是否已经启动完成。在某些情况下，容器启动需要一些时间，例如需要从外部下载数据、初始化数据、加载配置等。如果 Startup Probe 探测失败，则 Kubernetes 认为容器启动失败，并将自动重启该容器。只能使用命令行方式进行探测。

这些探针可以在 Pod 定义文件的 `spec.containers` 中进行配置

### 4. 探针的探测方式⭐⭐⭐⭐

1. HTTP 探针：通过 HTTP GET 或 POST 请求探测容器的健康状态。可以指定路径、端口、HTTP 头、请求参数等信息，以及期望的响应代码或响应内容。如果返回的响应码或响应内容与期望不符，则认为探测失败。
2. TCP 探针：通过向容器指定的 IP 地址和端口发送 TCP 连接请求来探测容器的健康状态。如果连接成功，则认为探测成功；否则认为探测失败。
3. Exec 探针：通过在容器内部运行一个指定的命令来探测容器的健康状态。可以指定要运行的命令、命令参数、执行超时时间等信息。如果命令执行成功并返回零退出代码，则认为探测成功；否则认为探测失败。

### 5. Init Container 的作用⭐⭐⭐⭐

在 Kubernetes 中，Init Container 是一种特殊类型的容器，它可以在 Pod 中的主要容器（也称为应用容器）启动之前运行。Init Container 可以执行一些初始化任务，例如：配置 Pod 中共享的数据卷、初始化数据库、检查依赖项等。 **在所有 Init Container 运行完毕后，主要容器才会启动** 。

与应用容器不同，Init Container 只会运行一次，即使 Pod 重新启动，也不会再次运行。Init Container 的退出状态不会影响主要容器的启动，只有在所有 Init Container 都运行成功后，主要容器才会启动。 **通过使用 Init Container，可以将一些复杂的初始化任务分离出来，从而简化应用容器的配置和管理** 。

### 6. Init Container 与应用容器的区别⭐⭐⭐⭐

Init Container 与应用容器的区别可以从以下几个方面进行比较：

1. 容器用途不同： Init Container 用于在应用容器启动之前运行一些初始化任务，例如创建必要的配置文件、初始化数据库等。应用容器则是运行应用程序的容器，它们的主要任务是提供应用程序服务。
2. 生命周期不同： Init Container 在 Pod 中的生命周期与应用容器不同，它们在应用容器启动之前运行，并且只有在它们完成了任务之后，应用容器才会启动。应用容器在完成任务后，可以保持运行状态，直到 Pod 被终止。
3. 配置不同： Init Container 不能设置 readinessProbe 探针，因为必须在它们成功运行后才能继续运行在 Pod 中定义的普通容器。

### 7. preStop 有什么作用⭐⭐⭐⭐

在 Kubernetes 中，preStop 是一个 Pod 生命周期钩子（Lifecycle Hook），用于在容器终止之前执行一些操作。在 Kubernetes 中，当需要终止一个 Pod 时，首先会向 Pod 发送一个 TERM 信号，然后等待一段时间（由 terminationGracePeriodSeconds 参数指定，默认为 30 秒），然后强制终止容器。在这个等待时间内，Kubernetes 允许容器执行一些清理操作，以确保数据的完整性和一致性。

preStop 钩子可以用于在容器终止之前执行一些操作，例如保存数据、关闭文件句柄、注销服务等等。preStop 钩子定义在 Pod 的容器中，并在容器终止之前自动执行。在 preStop 钩子执行期间，容器仍然可以处理请求和接受流量，但不会再接收新的请求和流量。

### 8. 说说镜像拉取策略⭐⭐⭐⭐

Kubernetes 支持以下三种镜像拉取策略：

1. Always：总是从镜像仓库拉取最新版本的镜像，适用于需要始终使用最新版本的应用程序。
2. IfNotPresent：仅当本地没有该镜像时才从镜像仓库拉取镜像，适用于不需要频繁更新的应用程序。
3. Never：仅使用本地已存在的镜像，如果本地不存在镜像则直接退出，适用于已经将镜像手动下载到本地的场景。

镜像拉取策略通常在 Pod 的 Spec 中通过 imagePullPolicy 字段来设置，默认值为 Always。例如：

```text
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent

```

### 9. 健康检查探针有哪些参数设置⭐⭐⭐⭐

在 Kubernetes 中，健康检查探针主要有以下三个参数：

* InitialDelaySeconds：在容器启动后多少秒开始进行健康检查。这个值适用于每一个容器，即使 Pod 中有多个容器也是一样的。
* PeriodSeconds：检查之间的时间间隔。例如，如果设置为 10s，则每 10 秒检查一次。
* TimeoutSeconds：每个健康检查的超时时间。如果容器在这个时间内没有响应，则认为它已经死亡并将其标记为不健康状态。

另外，还有两个可选参数：

* SuccessThreshold：连续成功多少次之后将容器标记为“健康”。默认为 1。
* FailureThreshold：连续失败多少次之后将容器标记为“不健康”。默认为 3。

### 10. Liveness Probe 和 Readiness Probe 有什么区别⭐⭐⭐⭐

Liveness Probe 是将检查失败的容器杀死，创建新的启动容器来保持 Pod 正常工作；

Readiness Probe 是，当 Readiness Probe 检查失败，并不重启容器，而是将 Pod 移出 Endpoint，Readiness Probe 确保了 Service 中的 Pod 都是可用的，确保客户端只与正常的 Pod 交互并且客户端永远不会知道系统存在问题。

### 11. 简单描述一下 Pod 的终止过程⭐⭐⭐⭐

1. 用户向 apiserver 发送删除 Pod 对象的命令；
2. apiserver 中的 Pod 对象信息会随着时间的推移而更新，在宽限期内（默认30s），Pod 被视为 dead；
3. 将 Pod 标记为 Terminating 状态；
4. endpoint 控制器监控到 Pod 对象的关闭行为时将其从所有匹配到此 endpoint 的 server 资源 endpoint 列表中删除；
5. 如果当前 Pod 对象定义了 preStop 钩子处理器，则在其被标记为 Terminating 后会意同步的方式启动执行；
6. Pod 对象中的容器进程收到停止信息；
7. 宽限期结束后，若 Pod 中还存在运行的进程，那么 Pod 对象会收到立即终止的信息；
8. kubelet 请求 apiserver 将此 Pod 资源的宽限期设置为 0 从而完成删除操作，此时 Pod 对用户已不可见。

## 十四、面试题

### 1. ReplicaSet 和 Deployment 的区别⭐⭐⭐⭐

1. 资源类型不同：Deployment 是高级别资源类型，而 ReplicaSet 是中级别资源类型。Deployment 控制 ReplicaSet 并协调应用程序的更新，而 ReplicaSet 则控制 Pod 的副本数量。
2. 功能不同：Deployment 的主要功能是管理应用程序的部署和更新，可以通过滚动升级策略来实现无宕机更新。而 ReplicaSet 则主要用于确保 Pod 的副本数量，通过调整 Pod 副本数量来适应应用程序的负载变化。

### 2. StatefulSet 和 Deployment 的区别⭐⭐⭐⭐

1. 管理的资源类型不同：Deployment 适用于无状态的应用程序，而 StatefulSet 则适用于有状态的应用程序，例如数据库、[消息队列](https://zhida.zhihu.com/search?content_id=239329008&content_type=Article&match_order=1&q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&zhida_source=entity)等。
2. Pod 的唯一性：在 StatefulSet 中，每个 Pod 都具有唯一的标识符和网络标识符，例如 hostname 和 DNS 名称等，这可以使 Pod 具有持久性和稳定性。而在 Deployment 中，Pod 的唯一性并不重要，因为 Pod 是无状态的。
3. 更新策略：在 Deployment 中，更新策略通常采用滚动更新的方式，即逐步替换旧的 Pod 副本。而在 StatefulSet 中，更新策略通常是有序的，每个 Pod 副本会按照其标识符的顺序进行更新，以确保应用程序的稳定性，采用 OnDelete 策略。
4. 存储管理：StatefulSet 通常需要对存储进行管理，以确保应用程序数据的持久性和稳定性。

### 3. Deployment 如何升级⭐⭐⭐⭐

Deployment 升级的基本流程如下：

1. 修改 Deployment 的 yaml 文件，将新的镜像版本号指定为 template.spec.containers.image 字段的值。
2. 使用 kubectl apply 命令来更新 Deployment 配置文件，例如： kubectl apply -f deployment.yaml
3. Kubernetes 会自动创建一个新的 ReplicaSet，将新的 Pod 副本部署到集群中。
4. 根据滚动更新策略，逐步替换旧的 Pod 副本，直到所有的 Pod 副本都已更新为新版本。

Deployment 需要确保在整个更新过程中只有一定数量的Pod可能处于不可用状态。在 Kubernetes 中，使用 **maxUnavailable** 和 **maxSurge** 这两个参数来定义滚动更新策略。

### 4. 说说 Deployment 如何滚动更新 Pod⭐⭐⭐⭐

1. Deployment 创建新的 ReplicaSet：在滚动更新开始之前，Deployment 会先创建一个新的 ReplicaSet，该 ReplicaSet 与原有的 ReplicaSet 具有相同的 Pod 模板和副本数量。
2. 更新 Pod 模板：在新的 ReplicaSet 中，将 Pod 模板中的镜像版本更新为新的版本。
3. 开始滚动更新：Deployment 控制新的 ReplicaSet 创建出一个新 Pod，然后旧 ReplicaSet 删除一个旧 Pod，这样交替逐步替换旧的 Pod 副本来实现滚动更新。具体来说，它按照两个参数进行控制：maxUnavailable: 允许的不可用 Pod 最大数量。在更新期间，Deployment 会将这些 Pod 从服务中删除，然后再创建新的 Pod。默认情况下，maxUnavailable 值为 25%。maxSurge: 允许的超出所需副本数的最大 Pod 数量。在更新期间，Deployment 会创建这些额外的 Pod，以确保在更新过程中有足够的可用副本。默认情况下，maxSurge 值为 25%。
4. 在滚动更新期间，Deployment 会逐步替换旧的 Pod 副本，直到所有 Pod 都已经更新为新的版本。如果在更新过程中发生故障，Deployment 会自动回滚到旧版本，以确保应用程序的可用性和稳定性。
5. 完成滚动更新：一旦所有的 Pod 都已经更新为新版本，Deployment 会自动删除旧的 ReplicaSet。

### 5. Deployment 更新过程中出现意外怎么办⭐⭐⭐

1. 首先，要进行备份和测试，以确保应用程序的可用性和数据的完整性。在进行更新之前，建议先备份应用程序的数据和配置，以便在出现问题时进行快速恢复。
2. 设置滚动更新策略：在 Deployment 中，可以设置滚动更新策略，包括 maxUnavailable 和 maxSurge 等参数，以控制更新过程中可用的 Pod 数量和超出所需副本数的最大 Pod 数量。
3. 回滚到旧版本：如果更新过程中出现问题，可以考虑回滚到旧版本。在 Kubernetes 中，可以通过 kubectl rollout 命令或使用 Kubernetes Dashboard 等工具来回滚 Deployment 到旧版本。

### 6. Deployment 怎么扩容或缩容？⭐⭐⭐

通过命令修改副本数：`kubectl scale deployment/my-first-deploy --replicas=3`

### 7. Deployment 的更新策略⭐⭐⭐⭐

Deployment 的升级策略主要有两种。

1、Recreate 重建更新：这种更新策略会杀掉所有正在运行的 Pod，然后再重新创建的 Pod；

2、rollingUpdate 滚动更新：这种更新策略，Deployment 会以滚动更新的方式来逐个更新 Pod，同时通过设置滚动更新的两个参数 maxUnavailable、maxSurge 来控制更新的过程。

## 十五、面试题

### 1. 说说 StatefulSet，有什么特点？⭐⭐⭐⭐

StatefulSet 是 Kubernetes 中的一种控制器对象，它 **用于管理有状态的应用程序，例如数据库或其他需要持久化存储的应用程序** 。与 Deployment 不同，StatefulSet 会为每个 Pod 分配一个唯一的稳定标识符，这个标识符在 Pod 的整个生命周期内都不会发生变化。

StatefulSet 的主要特点包括：

* 有序部署：与 Deployment 不同，StatefulSet 会按顺序部署 Pod，每个 Pod 都会按顺序启动和关闭。这对于有状态应用程序非常重要，因为它们可能需要特定的启动顺序和关闭顺序来保证数据的完整性。
* 稳定的网络标识符：StatefulSet 为每个 Pod 分配一个唯一的网络标识符，这个标识符在 Pod 的整个生命周期内都不会改变。
* 有状态存储：StatefulSet 支持有状态应用程序的存储需求，例如使用 Persistent Volume 或 Persistent Volume Claim 来管理数据卷。
* 扩展和缩放：StatefulSet 能够自动扩展和缩放有状态应用程序。当需要增加副本时，StatefulSet 会按照指定的顺序创建新的 Pod，并将数据复制到新的 Pod 中。当需要减少副本时，StatefulSet 会按照指定的顺序关闭 Pod，并将数据迁移到其他 Pod 中，从而保证数据的完整性和可用性。

### 2. StatefulSet 如何保证应用程序的可用性和稳定性⭐⭐⭐⭐

StatefulSet 通过以下几种方式来保证应用程序的可用性和稳定性：

1. 稳定的网络标识符：StatefulSet 为每个 Pod 分配一个唯一的网络标识符，这个标识符在 Pod 的整个生命周期内都不会改变。这使得有状态应用程序能够持久化存储数据，同时保证数据的可用性和一致性。
2. 有序部署和更新：StatefulSet 按照指定的顺序部署和更新 Pod。这对于有状态应用程序非常重要，因为它们可能需要特定的启动顺序和关闭顺序来保证数据的完整性。在更新期间，StatefulSet 保证在更新前新 Pod 已经准备就绪，并且只有一个 Pod 被更新。
3. 有状态存储：StatefulSet 支持有状态应用程序的存储需求，例如使用 Persistent Volume 或 Persistent Volume Claim 来管理数据卷。通过使用这些机制，StatefulSet 可以确保数据不会丢失或损坏。
4. 自动扩展和缩放：StatefulSet 能够自动扩展和缩放有状态应用程序。当需要增加副本时，StatefulSet 会按照指定的顺序创建新的 Pod，并将数据复制到新的 Pod 中。当需要减少副本时，StatefulSet 会按照指定的顺序关闭 Pod，并将数据迁移到其他 Pod中，从而保证数据的完整性和可用性。

### 3. 说说 StatefulSet 更新策略⭐⭐⭐⭐

StatefulSet 的更新策略分为两种：RollingUpdate 和 OnDelete。

1. 滚动更新（RollingUpdate）： RollingUpdate 是默认的更新策略，它会依次更新每个 Pod，保证在更新过程中应用程序的可用性和稳定性。具体地，滚动更新会按照指定的顺序逐个替换 Pod，每次只替换一个 Pod，新的 Pod 创建成功后再删除旧的 Pod，直到所有 Pod 都被更新为止。
2. 批量更新（OnDelete）：OnDelete 是另一种更新策略，它需要手动设置。在批量更新策略下，用户需要手动删除旧的 Pod，然后再创建新的 Pod。这种方式比较适用于一次性更新多个 Pod 的场景。

在 StatefulSet 更新过程中，还可以通过以下几个参数来调整更新策略：

* spec.updateStrategy.type：更新策略类型，可选值为 RollingUpdate 和 OnDelete。
* spec.updateStrategy.rollingUpdate：滚动更新的参数，包括 maxUnavailable 和 maxSurge，用于指定更新过程中同时可用和不可用的 Pod 的数量。
* spec.podManagementPolicy：Pod 管理策略，可选值为 OrderedReady 和 Parallel。如果选择 OrderedReady，StatefulSet 将按照指定的顺序管理 Pod，等待每个 Pod 就绪后再创建下一个 Pod。如果选择 Parallel，StatefulSet 将同时管理所有的 Pod。

### 4. 说说 StatefulSet RollingUpdate 工作原理⭐⭐⭐⭐

当更新策略设置为 RollingUpdate 时，StatefulSet Controller 会删除并创建 StatefulSet 相关的每个 Pod 对象，其处理顺序与 StatefulSet 终止 Pod 的顺序一致，即从序号最大的 Pod 开始重建，每次更新一个 Pod。如果更新过程中，小序号的 Pod 出现故障，那么更新就会被打断。

总结就是  **StatefulSet 创建 Pod，序号由小到大；删除、更新 Pod，序号由大到小** 。

### 5. 说说 StatefulSet 的灰度升级（[金丝雀](https://zhida.zhihu.com/search?content_id=239329008&content_type=Article&match_order=1&q=%E9%87%91%E4%B8%9D%E9%9B%80&zhida_source=entity)发布）⭐⭐⭐⭐

StatefulSet 的灰度升级可以通过以下步骤实现：

1. 创建一个新的 StatefulSet，用于部署新版本的应用程序。此时，新的 StatefulSet 与旧的 StatefulSet 并存。
2. 逐步将新版本的 Pod 逐个加入到新的 StatefulSet 中，并保证新版本和旧版本的 Pod 共存一段时间。在这个过程中，可以使用滚动升级来逐步替换旧版本的 Pod。StatefulSet partition 参数用于控制 StatefulSet 的滚动升级过程。通过指定 partition 的值，可以让 StatefulSet 只更新部分 Pod，而不是一次性更新所有 Pod。
3. 对于新版本的 Pod，可以通过标签选择器来确保它们只接收一小部分流量，从而进行灰度升级。这可以通过在 Service 中指定 Selector 和 EndpointSlices 来实现。
4. 当新版本的 Pod 被成功加入新的 StatefulSet 后，可以逐渐删除旧版本的 Pod。在删除旧版本的 Pod 时，需要确保数据的持久性不会丢失，例如使用云存储或网络存储等方式。

### 6. 如何保证 StatefulSet 中的 Pod 在重新调度后能够保留数据？⭐⭐⭐⭐

StatefulSet 中的 Pod 可以使用 PersistentVolumeClaim（PVC）来访问持久化存储。当 Pod 重新调度时，它们将重新连接到相应的 PVC，并在新的节点上重新挂载相应的持久卷。同时，还可以使用 StatefulSet 的 spec.volumeClaimTemplates 字段来指定要创建的 PVC 模板，以确保持久化存储的一致性和可用性。

### 7. StatefulSet 如何进行有序的、逐个更新？⭐⭐⭐⭐

StatefulSet 提供了更新策略和 rolling update 策略，以确保有序的、逐个更新。更新策略包括 OnDelete 和 RollingUpdate 两种方式，RollingUpdate 又分为两种：删除策略为 Parallel 和 OrderedReady。在 OrderedReady 方式下，StatefulSet 会等待前一个 Pod 更新完成并且处于 Running 状态后，才会进行下一个 Pod 的更新。

### 8. 如果在 StatefulSet 中增加一个 Pod，该 Pod 的名称是如何生成的？⭐⭐⭐

具体生成方式是：StatefulSet 的名称作为基础名称，加上 Pod 的序号，用“-”符号进行连接，例如，如果 StatefulSet 的名称是“web”，则第一个 Pod 的名称为“web-0”，第二个 Pod 的名称为“web-1”，以此类推。

### 9. StatefulSet 如何进行有状态存储管理？⭐⭐⭐⭐

1.创建 Pod 时

StatefulSet 额外添加了一个 volumeClaimTemplates 字段。它跟 Deployment 里 Pod 模板（PodTemplate）的作用类似。也就是说，凡是被这个 StatefulSet 管理的 Pod，都会声明一个对应的 PVC；而这个 PVC 的定义，就来自于 volumeClaimTemplates 这个模板字段。 **更重要的是，这个 PVC 的名字，会被分配一个与这个 Pod 完全一致的编号** 。

这个自动创建的 PVC，与 PV 绑定成功后，就会进入 Bound 状态，这就意味着这个 Pod 可以挂载并使用这个 PV 了。

2.删除 Pod 时

当删除一个 Pod 之后，这个 Pod 对应的 PVC 和 PV，并不会被删除，而这个 Volume 里已经写入的数据，也依然会保存在远程存储服务里（比如，我们在这个例子里用到的 Ceph 服务器）。

此时，StatefulSet 控制器发现，一个例如名叫 web-0 的 Pod 消失了。所以，控制器就会重新创建一个新的、名字还是叫作 web-0 的 Pod 来，“纠正”这个不一致的情况。

在这个新的 Pod 对象的定义里，它声明使用的 PVC 的名字，还是叫作：例如 www-web-0。这个 PVC 的定义，还是来自于 PVC 模板（volumeClaimTemplates），这是 StatefulSet 创建 Pod 的标准流程。所以，在这个新的 web-0 Pod 被创建出来之后，Kubernetes 为它查找名叫 www-web-0 的 PVC 时，就会直接找到旧 Pod 遗留下来的同名的 PVC，进而找到跟这个 PVC 绑定在一起的 PV。这样，新的 Pod 就可以挂载到旧 Pod 对应的那个 Volume，并且获取到保存在 Volume 里的数据。 **通过这种方式，Kubernetes 的 StatefulSet 就实现了对应用存储状态的管理** 。

## 十六面试题

### 1. 什么是 DeamonSet⭐⭐⭐⭐

DaemonSet 是 Kubernetes 中的一种资源对象，用于确保每个节点（Node）上都运行着一个 Pod 的副本。DaemonSet 通常用于需要在每个节点上运行一个实例的系统级别的任务，例如日志收集器、监视器或存储代理等。

与 Deployment 不同的是，DaemonSet 会在每个节点上创建一个 Pod，而不是在整个集群中创建一组 Pod。当新的节点加入集群时，Kubernetes 会自动为它们创建一个对应的 Pod。同样，当节点从集群中删除时，相应的 Pod 也会被自动删除。

### 2. DeamonSet 与 Deployment 的区别⭐⭐⭐⭐

1. Pod 副本数：Deployment 会在集群中创建指定数量的 Pod 副本，而 DaemonSet 会为每个节点创建一个 Pod 副本。
2. 部署对象：Deployment 适用于无状态应用，而 DaemonSet 通常用于需要在每个节点上运行一个实例的系统级别的任务，例如日志收集器、监视器或存储代理等。
3. 更新策略：Deployment 支持滚动升级（Rolling Update），而 DaemonSet 不支持滚动升级。在更新 DaemonSet 时，需要手动将旧 Pod 删除并创建新的 Pod。
4. 调度策略：Deployment 默认会将 Pod 均匀地分布在集群中的不同节点上，而 DaemonSet 会将 Pod 部署到每个符合选择器的节点上。

### 3. 什么是 Job，应用场景是什么⭐⭐⭐⭐

Job 是 Kubernetes 中一种用于批处理作业的控制器。它可以在集群中创建一个或多个 Pod，并保证这些 Pod 成功运行完成，然后退出。Job 的应用场景包括：

* 执行一次性任务：Job 可以用于执行一些一次性任务，例如数据备份、数据迁移、数据处理等。
* 执行定时任务：Job 可以按照预定的时间间隔运行，例如定时备份数据库、日志清理等。
* 执行批处理任务：Job 可以按照预定的步骤执行批处理任务，例如数据清洗、数据分析等。

Job 可以保证其中的 Pod 成功运行完成，然后退出。如果 Pod 在执行任务期间失败，Job 会尝试重新创建一个新的 Pod，直到所有任务都成功完成。 **Job 的主要特点是一旦任务完成后，Job 控制器会将 Pod 自动删除，这使得 Job 可以用于一次性任务和临时任务的执行** 。

### 4. Job 的 Pod 的重启策略一般设置为什么⭐⭐⭐⭐

`restartPolicy=Never`

原因： **离线计算的 Pod 永远都不应该被重启，否则它们会再重新执行一遍** 。

也可以定义为 `restartPolicy=OnFailure`，那么离线作业失败后，Job Controller 就不会去尝试创建新的 Pod。 **但是，它会不断地尝试重启 Pod 里的容器** 。

### 5. DaemonSet 资源对象的特性是什么⭐⭐⭐⭐

DaemonSet 是 Kubernetes 中的一种资源对象，用于在集群中运行一个 Pod 的副本，确保在集群的每个节点上都运行一个 Pod 的副本。

### 6. DaemonSet 如何确保在集群的每个节点上都运行一个 Pod 的副本⭐⭐⭐⭐

DaemonSet Controller，首先从 Etcd 里获取所有的 Node 列表，然后遍历所有的 Node。这时，它就可以很容易地去检查，当前这个 Node 上是不是有一个携带了 `app=my-first-daemonset` 标签的 Pod 在运行。

而检查的结果，可能有这么三种情况：

1. 没有这种 Pod，那么就意味着要在这个 Node 上创建这样一个 Pod；
2. 有这种 Pod，但是数量大于 1，那就说明要把多余的 Pod 从这个 Node 上删除掉；
3. 正好只有一个这种 Pod，那说明这个节点是正常的。

### 7. DaemonSet 的更新策略是什么？⭐⭐⭐⭐

更新策略只有 OnDelete 一种，从 Kubernetes 1.6 之后版本，OnDelete 为 DeamonSet 默认的更新策略，即更新时，需要手动删除 Pod。

### 8. 如果一个 Pod 运行失败，Job 会怎样处理？⭐⭐⭐⭐

Job 将会根据设置的 restartPolicy 参数来确定如何处理这个失败的 Pod。restartPolicy 可以设置为以下两个选项：

* OnFailure：当 Pod 失败时，仅重新启动该 Pod 里的容器。
* Never：如果 Pod 失败，则 Job 停止，并且不会重新启动该 Pod 里的容器。这时 Job 根据设置的参数 backoffLimit 字段，来决定 Job 运行失败时重试的次数。如果还是失败，就需要管理员手工介入。

## 十七、面试题

### 1. 说一下 HPA 自动扩缩容机制⭐⭐⭐

HPA（Horizontal Pod Autoscaler）是 Kubernetes 中一种自动扩缩容机制，它可以根据预定义的指标来 **自动调整 Pod 的数量** ，以达到更好的负载均衡和性能。

HPA 根据**监控指标**来决定是否需要自动扩缩容，监控指标通常包括 **CPU 使用率、内存使用率、网络流量**等。当监控指标超过了预设的阈值时，HPA 将自动创建或销毁 Pod，以增加或减少集群中的计算资源。

### 2. HPA 根据哪些指标进行自动扩缩容？⭐⭐⭐

* Pod 的资源使用率，例如 CPU 使用率
* Pod 自定义指标，例如接收的请求数量
* Object 自定义指标或外部定义指标，需要容器应用以某种方式提供，例如通过 HTTP URL“/metrics” 提供， 或者使用外部服务提供的指标采集 URL

### 3. HPA 如何设置扩容和缩容的阈值？⭐⭐⭐

1. 根据 CPU 利用率或内存利用率设置阈值：可以通过设置 CPU 利用率或内存利用率的百分比来设置扩缩容的阈值。例如，可以将 CPU 利用率的阈值设置为 80%，这意味着当 Pod 中的 CPU 利用率超过 80% 时，HPA 将开始扩展 Pod 的数量。
2. 根据自定义指标设置阈值：除了 CPU 利用率和内存利用率之外，HPA 还可以根据其他自定义指标来设置扩缩容的阈值，例如请求数、响应时间、网络流量等。

### 4. HPA 如何保证不会造成过度扩容或过度缩容？⭐⭐⭐

在 HPA 中，控制相关参数来保证不会造成过度扩容或过度缩容：

* targetCPUUtilizationPercentage 是指 HPA 监控的指标，也就是 Pod 的 CPU 利用率目标值，当 CPU 利用率超过该值时，HPA 就会自动触发扩容策略；当 CPU 利用率低于该值时，HPA 就会自动触发缩容策略。
* tolerance 则是指在扩容和缩容时，为避免出现频繁扩缩容，HPA 会对目标 CPU 利用率设置一个容忍度，即可以超出目标 CPU 利用率的百分比范围。容忍度通过 kube-controller-manager 服务的启动参数 --horizontal-pod-autoscaler-tolerance 进行设置，默认值为 0.1（即10%），表示基于上述算法得到的结果在 [-10%, +10%] 区间内，即 [0.9, 1.1] 区间，控制器都不会进行扩缩容操作
* 使用 HPA 特性时，可能因为指标动态的变化造成 Pod 副本数量频繁变动，这也被称为“抖动”。增加参数 Horizontal-pod-autoscaler-downscale-stabilization（kube-controller-manager 服务的参数）来解决这个问题。它表示 HPA 扩缩容过程中的冷却时间，即从上次扩缩容执行结束后，需要经过最少多长时间才可以再次执行扩缩容操作。当前的默认时间时 5min。

### 5. HPA 的自动扩缩容机制是否适用于所有应用程序？有哪些应用程序不适合使用 HPA？⭐⭐

在以下情况下，HPA 的效果可能会受到限制：

* 对于非 CPU 密集型的应用程序，HPA 可能无法检测到实际的应用程序负载，从而导致扩缩容不准确。
* 对于长时间运行的任务，例如数据分析、机器学习等计算密集型任务，如果这些任务的运行时间超过了 HPA 中设置的评估间隔，那么 HPA 就无法对这些任务进行有效地扩缩容。
* 对于网络延迟较大的场景，例如跨区域部署的应用程序，HPA 可能无法及时检测到负载变化，从而导致扩缩容不准确。
* 对于具有复杂依赖关系的应用程序，例如数据库、消息队列等，HPA 的扩缩容可能会影响应用程序的整体稳定性。

### 6. HPA 可以扩展哪些类型的资源？⭐⭐⭐

HPA（Horizontal Pod Autoscaler）可以扩展 Deployment、ReplicaSet 和 StatefulSet 中管理的 Pod 资源。它无法扩展其他类型的资源，如 DaemonSet 和 CronJob。这是因为 DaemonSet 负责在每个节点上运行一个 Pod，而 CronJob 可以在特定时间运行一个或多个 Job，它们都不适合自动扩展。

## 十八、面试题

### 1. Label 有什么作用？它们在 Kubernetes 中的应用场景是什么？⭐⭐⭐⭐

在 Kubernetes 中，Label 用于标识 Kubernetes 对象，它是一个 key-value 格式的元数据。Label 的作用有以下几个方面：

1. 标识 Kubernetes 对象：Label 可以用来标识一个 Kubernetes 对象，如 Pod、Service、Deployment 等。
2. 分类和组织：可以使用 Label 对 Kubernetes 对象进行分类和组织，比如将具有相同用途或者相同特性的 Pod 使用相同的 Label 进行标识。
3. 筛选和查询：可以使用 Label Selector 对 Kubernetes 对象进行筛选和查询，以便找到符合特定要求的对象。
4. 控制器的控制：在 Kubernetes 中，一些控制器（如 Deployment、StatefulSet）会使用 Label 来控制它们所管理的对象。

### 2. 如何在 Kubernetes 中使用 Selector（标签选择器） 来查询资源？⭐⭐⭐

`kubectl get`

命令格式：

```text
kubectl get <resource_type> -l <label>

```

`resource_type` 可以为 Kubernetes 中的任何资源，如 Pod、Node、Deployment、Service等；`label` 为需要查询的标签，格式为 `key1=value1,key2=value2`。

### 3. Label 和 Selector 之间的关系是什么？⭐⭐⭐⭐

Label 是一种键值对，可以应用于 Kubernetes 中的各种资源对象，例如 Pod、Service、ReplicaSet 等。Label 可以用来标识一个或多个资源，以便更方便地对它们进行管理和筛选。

而 Selector 则是一种用于选择具有特定 Label 的 Kubernetes 资源的机制。通过指定一个或多个 Label 的匹配规则，可以选择匹配这些规则的资源对象，以便对它们进行操作。

因此，可以说 Selector 是通过匹配 Label 来实现对 Kubernetes 资源对象进行选择的一种机制。使用 Label 和 Selector 可以实现资源对象的分类、筛选、管理、扩展等功能

### 4. Kubernetes 中如何给一个对象添加或修改 Label？又如何删除？⭐⭐⭐

`kubectl label`

命令格式：

```text
kubectl label <resource_type> <resource_name> <label>

```

`resource_type` 可以为 Kubernetes 中的任何资源，如 Pod、Node、Deployment、Service等；`resource_name` 为资源的具体名称； `label` 为需要添加的标签，格式为 `key1=value1,key2=value2`。

删除标签：

```text
kubectl label <resource_type> <resource_name> <label->

```

`resource_type` 可以为 Kubernetes 中的任何资源，如 Pod、Node、Deployment、Service等；`resource_name` 为资源的具体名称； `label` 为需要删除的标签，格式为 `key1-,key2-`。

## 十九、面试题

### 1. 什么是 Node Affinity？⭐⭐⭐

Node Affinity 是 Kubernetes 中的一种调度机制，允许 Pod 在调度到节点时对节点进行约束和限制。通过使用 Node Affinity，可以控制 Pod 在哪些节点上可以运行或不能运行，从而优化应用程序的性能和资源使用情况。

Node Affinity 可以根据节点的标签或其他属性，将 Pod 调度到满足特定需求的节点上。例如，可以将某些应用程序调度到具有 GPU 资源的节点上，以获得更好的性能。

### 2. Node Affinity 有哪些类型？⭐⭐⭐

Node 亲和性有两种类型：

* requiredDuringSchedulingIgnoredDuringExecution：这种类型的 Node 亲和性是必需的，并且在调度 Pod 时必须考虑。如果没有符合条件的节点，Pod 将无法调度。这是一种硬限制。
* preferredDuringSchedulingIgnoredDuringExecution：这种类型的 Node 亲和性是一种软限制，并且可以被忽略。如果没有符合条件的节点，Pod 仍然可以被调度。但是，如果有多个节点符合条件，可以设置权重值，则将尽可能选择优先级最高的节点。

 **IgnoredDuringExecution的意思是，如果在 Pod 运行时节点的标签被更改或删除，则不会将 Pod 驱逐出该节点** 。

### 3. Node Affinity 与其他调度机制（如 Taints 和 Tolerations、Node Selector 等）之间有什么区别？⭐⭐⭐

Node Affinity、Taints 和 Tolerations、Node Selector 等都是 Kubernetes 中用于进行节点调度的机制，它们之间的区别如下：

1. Node Affinity：Node Affinity 允许 Pod 定义要求它所调度到的节点必须或者必须不具备的一些属性。通过设置节点上的 Label，可以使用 Node Affinity 来选择满足特定要求的节点。
2. Taints 和 Tolerations：Taints 和 Tolerations 允许集群管理员设置某些节点上的 Taints，以阻止 Pod 在该节点上运行。Pod 可以使用 Tolerations 来容忍特定的 Taints，从而仍然可以在被 Taint 的节点上运行。
3. Node Selector：Node Selector 允许用户根据节点的 Label 进行过滤，选择满足特定要求的节点。Pod 可以使用 Node Selector 来指定要求所在节点必须具有特定 Label。

总的来说，Node Affinity 更加灵活，可以选择更多的节点属性；而 Taints 和 Tolerations 只能进行简单的选择和容忍；Node Selector 也只能根据节点 Label 进行简单的选择。

### 4. 如何设置多个 Node Affinity 规则以进行更细粒度的节点调度？⭐⭐⭐

可以使用 nodeSelectorTerms 和 preferredDuringSchedulingIgnoredDuringExecution 或 requiredDuringSchedulingIgnoredDuringExecution 来设置多个 Node Affinity 规则以进行更细粒度的节点调度。

### 5. 什么是 soft 和 hard Node Affinity？⭐⭐⭐

当使用 soft Node Affinity 时，如果无法满足规则中的要求，Pod 仍然可以被调度到不符合规则的节点上。但是如果能够满足规则，调度程序会优先将 Pod 调度到符合规则的节点上。

相比之下，使用 hard Node Affinity 时，如果规则中的要求无法满足，则调度程序不会将 Pod 调度到不符合规则的节点上。这种情况下，Pod 可能一直处于未调度状态，直到有节点满足规则要求。
