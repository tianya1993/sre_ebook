## 1. Namespace

- UTS   主机名 域名
- Mount  文件系统
- Network 网络协议栈
- User 用户隔离
- PID 进程号
- IPC 进程通信

## 2. Cgroup

 有 V1 和 V2 版本的区别，主要是层级结构的变化

 CPU
    cpuset   绑定核心
    cpu.shares  1024 根据比例分配 CPU
    cpu.cfs_period_us 100000us 100ms
    cpu.cfs_quota_us

 Memory
   max limit

 IO

## 3. CPU 的四种进程调度

## 4. Linux 的进程调度

- CFS（Completely Fair Scheduler）
  是 Linux 内核中的默认进程调度器。它主要用于公平地分配 CPU 时间给各个进程，确保所有进程在 CPU 时间的使用上尽可能公平。

CFS 的主要特点

- 公平性：
  CFS 的设计目标是确保所有进程都能公平地获得 CPU 时间。每个进程根据其优先级和 CPU 使用情况被分配时间片。
- 时间片：
  CFS 不使用固定的时间片，而是根据进程的权重（优先级）动态计算每个进程应该获得的 CPU 时间。高优先级的进程会获得更多的 CPU 时间。
- 红黑树：
  CFS 使用红黑树数据结构来管理可运行的进程。每个进程在树中的位置根据其“虚拟运行时间”（vruntime）来决定。vruntime 是进程实际运行时间与其权重的比值，权重越高，vruntime 增加得越慢。
- 上下文切换：
  CFS 尽量减少上下文切换的成本，通过选择 vruntime 最小的进程来进行调度，从而实现低延迟和高吞吐量。
- 优先级：
  CFS 支持动态优先级调整。进程在 CPU 上运行的时间越长，其优先级（nice 值）就会逐渐降低，反之亦然，这样可以避免某些进程长期占用 CPU。
  配置 CFS 调度器

1. 查看当前调度策略
   您可以使用 ps 命令查看当前进程的调度策略：

```bash
ps -eo pid,comm,cls,nice
其中，cls 列显示调度策略，CFS 使用的调度策略是 SCHED_OTHER。
```

1. 修改进程的优先级
   您可以使用 nice 和 renice 命令来调整进程的优先级：

使用 nice 创建新进程时设置优先级：

```dotnetcli
nice -n 10 ./your_program
```

使用 renice 修改运行中进程的优先级：

```dotnetcli
renice -n 10 -p <pid>

```

### 4.1 CFS 的调度过程

进程进入就绪队列：
当进程准备好运行时，它会进入就绪队列，并根据其 vruntime 进行排序。
选择进程：
CFS 从就绪队列中选择 vruntime 最小的进程进行调度。
时间片管理：
被调度的进程会运行，直到它的时间片用完、被更高优先级的进程抢占，或自愿放弃 CPU。
上下文切换：
当需要调度其他进程时，CFS 会进行上下文切换，将当前进程的状态保存到内存，并加载下一个进程的状态。
总结
CFS 通过使用 vruntime 和红黑树数据结构实现了公平、高效的 CPU 调度。它支持动态优先级调整，可确保所有进程都能获得合理的 CPU 时间。了解 CFS 的工作原理和配置方法可以帮助您更好地管理系统性能和资源使用

## 5. Linux 的五种 IO 模型

1. 阻塞 I/O（Blocking I/O）
   描述：在阻塞 I/O 模型中，当进程发起 I/O 操作时，进程会被挂起，直到操作完成。对于读取操作，进程会等待数据到达；对于写入操作，进程会等待数据被成功写入。
   **优点：**
   简单易用，编程模型直观。
   **缺点：**
   效率较低，特别是在等待 I/O 时，CPU 无法执行其他任务。
2. 非阻塞 I/O（Non-blocking I/O）
   描述：在非阻塞 I/O 模型中，进程发起 I/O 操作后，如果操作不能立即完成，进程不会被挂起，而是立即返回。这意味着进程可以继续执行其他任务，并在之后再次检查 I/O 操作的状态。
   优点：
   提高了 CPU 的使用率，允许进程做其他工作。
   缺点：
   编程复杂性增加，需要轮询或使用其他机制来检查 I/O 操作的完成。
3. I/O 多路复用（I/O Multiplexing）
   描述：使用 select()、poll() 或 epoll() 等系统调用，进程可以监视多个 I/O 流并等待其中一个或多个变为可读或可写。进程可以同时处理多个连接。
   优点：
   适用于需要处理大量并发连接的场景，如网络服务器。
   缺点：
   使用复杂，尤其在管理多个文件描述符时。
4. 信号驱动 I/O（Signal-driven I/O）
   描述：在信号驱动 I/O 模型中，进程可以注册一个信号处理程序，当 I/O 操作准备好时，内核会发送一个信号（如 SIGIO）给进程。进程在收到信号后可以执行相应的处理。
   优点：
   允许进程在 I/O 准备好时被通知，避免了轮询。
   缺点：
   信号处理的复杂性，可能会导致信号丢失或处理顺序问题。
5. 异步 I/O（Asynchronous I/O）
   描述：在异步 I/O 模型中，进程发起 I/O 操作后立即返回，并可以在操作完成时通过回调函数或其他机制被通知。当 I/O 操作完成后，数据会自动被传输到指定的缓冲区。
   优点：
   高效，允许进程在 I/O 操作完成时继续执行其他任务。
   缺点：
   实现复杂性较高，需要支持异步操作的库或框架。

### 5.1 多路复用模型

**select**

**poll**

**epoll**

Go 语言网络 IO 模型之 epoll
