最近阅读了《redis设计与实现》，这是一本比较枯燥的书，毕竟涉及到redis底层数据结构。我写本文章的目的，主要围绕redis设计与实现这本书整体的一个印象，然后梳理了这次思路：

1. 为什么要选择Redis：介绍Redis的使用场景与使用Redis的原因；
2. Redis常用命令总结：包括时间复杂度总结与具体数据类型在Redis内部使用的数据结构；
3. Redis的高级功能：包括持久化、复制、哨兵、集群介绍；
4. 理解Redis：理解内存、阻塞；这部分是非常重要的，前面介绍的都可以成为术，这里应该属于道的部分；
5. 开发技巧：主要是一些开发实战的总结，包括缓存设计与常见坑点。

<br>

## 背景

在面试的时候，常被问比较下Redis与Memcache的优缺点，个人觉得这二者并不适合一起比较，一个是非关系型数据库不仅可以做缓存还能干其它事情，一个是仅用做缓存。常常让我们对这二者进行比较，主要也是由于Redis最广泛的应用场景就是Cache。那么Redis到底能干什么？又不能干什么呢？

注：笔者会在以后的文章来分析Redis与Memcache的优缺点。

<br>

## Redis能做什么

1. 缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；

2. 排行榜，如果使用传统的关系型数据库来做这个事儿，非常的麻烦，而利用Redis的SortSet数据结构能够非常方便搞定；

3. 计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；

   注：限速器也是对请求限流的一种实现方式。

4. 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；

5. 简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；

6. Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。

   注：对于基于Redis实现分布式session 笔者会在以后文章接入说明

   <br>

## Redis不能做什么

Redis感觉能干的事情特别多，但它不是万能的，合适的地方用它事半功倍。如果滥用可能导致系统的不稳定、成本增高等问题。

比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。

简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis。

数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。如果不担心浪费资源，那请忽略。

<br>

## Redis为什么能做这些

上面说了Redis的一些使用场景，那么这些场景的解决方案也有很多其它选择，比如缓存可以用Memcache，Session共享还能用MySql来实现，消息队列可以用RabbitMQ，我们为什么一定要用Redis呢？

那是因为Redis执行速度快：

- 速度快，完全基于内存；
- 使用C语言实现，基于非阻塞的 IO 多路复用机制，网络层使用epoll解决高并发问题；
- 单线程模型避免了不必要的上下文切换及竞争条件；

注意：单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理

丰富的数据类型；

Redis有8种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这5种类型（还有Bitmaps-位图、HyperLogLog、GEO-地理信息定位），他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）；

除了提供的丰富的数据类型，Redis还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。

Redis的代码开源在GitHub，代码非常简单优雅，任何人都能够吃透它的源码；它的编译安装也是非常的简单，没有任何的系统依赖；有非常活跃的社区，各种客户端的语言支持也是非常完善。另外它还支持事务（没用过）、持久化、主从复制让高可用、分布式成为可能。

做为一个开发者，对于我们使用的东西不能让它成为一个黑盒子，我们应该深入进去，对它更了解、更熟悉。

<br>

### redis 的线程模型

redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 socket
- IO 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

来看客户端与 redis 的一次通信过程：

![redis-single-thread-model](../../image/redis-single-thread-model.png)

客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 `AE_READABLE` 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给**连接应答处理器**。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 `AE_READABLE` 事件与命令请求处理器关联。

假设此时客户端发送了一个 `set key value` 请求，此时 redis 中的 socket01 会产生 `AE_READABLE` 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 `AE_READABLE` 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 `key value` 并在自己内存中完成 `key value` 的设置。操作完成后，它会将 socket01 的 `AE_WRITABLE` 事件与命令回复处理器关联。

如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 `AE_WRITABLE` 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 `ok`，之后解除 socket01 的 `AE_WRITABLE` 事件与命令回复处理器的关联。

这样便完成了一次通信。



## 总结Redis特性

1. 速度快

   数据存放在内存中；单线程模式，避免了线程上下文切换及多线程竞争访问；c语言实现，更容易接近系统api；采用epoll非阻塞IO，不在网络上浪费时间；

2. 支持多种数据类型

   支持8种数据类型：String、Hash、List、Set、 SortSet、Bitmaps、HyperLogLog、GEO；

3. 功能丰富

   丰富的API，如可设置键过期，存在即设置（这可以用来解决分布式锁问题），基于发布订阅可实现简单的消息队列，通过Lua创建新命令，具有原子性，管道（pipeline）功能，解决网络开销；

4. 服务器简单

   开源代码优雅，容易阅读源码，采用单线程模型，避免并发问题，redis自己实现了多路复用；

5. 客户端语言版本多

   如Java、Php、Go

6. 支持多种持久化方式

   RDB和AOP，这两种持久化深入分析请看：https://blog.csdn.net/u014229282/article/details/81121214

7. 支持集群部署

   支持主从复制，高可用集群，内部集群方式与Memcache做集群实现不一样的机制。

<br>

本文章来源：https://github.com/Zeb-D/my-review

