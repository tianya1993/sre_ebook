本文章来源于：<https://github.com/Zeb-D/my-review> ，请star 强力支持，你的支持，就是我的动力。

[TOC]

------

## synchronized

JVM 是通过进入和退出对象监视器来实现同步的。Java 中的每一个对象都可以作为锁。

- 对于普通同步方法，锁是当前实例对象
- 对于静态同步方法，锁是当前类的Class对象
- 对于同步代码块，锁是synchronized括号里配置的对象



### 锁优化

JDK 1.6 中对 synchronized 进行了优化，为了减少获取和释放锁带来的消耗引入了偏向所和轻量锁。也就是说锁一共有四种状态，级别从低到高分别是：无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态。锁可以升级但是不能降级。



#### Java头

synchronized 使用的锁是存放在 Java 对象头中的。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。

Java 头中包含了Mark Word,用来存储对象的 hashCode 或者锁信息，在运行期间其中存储的数据会随着锁的标志位的变化而变化。

![img](https://user-gold-cdn.xitu.io/2018/12/25/167e53d267966323?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 偏向锁

大多数情况下，锁不仅不存在多线程竞争，而且总是由统一线程多次获得，为了让线程获取锁的代价更低而引入了偏向锁。

它的核心思想是：如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较好的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。

释放锁：当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。

![img](https://user-gold-cdn.xitu.io/2018/12/25/167e53810f173193?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 轻量级锁

**加锁：**当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock   Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。如果更新成功，当前线程就获得了锁。如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。不是则说明有其他线程抢占了锁，尝试使用自旋锁来获取锁。

**解锁：**轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁)

#### 三种锁的对比：

| 锁类型  | 优点                               | 缺点                      | 使用场景             |
| ---- | -------------------------------- | ----------------------- | ---------------- |
| 偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度             | 如果始终得不到锁竞争的线程使用自旋会消耗CPU | 追求响应时间,锁占用时间很短   |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                | 线程阻塞，响应时间缓慢             | 追求吞吐量,锁占用时间较长    |



### volatile和synchronized比较

- volatile 本质是告诉jvm当前变量在工作内存中的值是不确定的，需要从主存读取；synchronized 是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞
- volatile 只能使用在变量级别；synchronized 可以使用在变量、方法和类级别
- volatile 仅能实现变量可见性，不能保证原子性；synchronized 可以保证变量的可见性和原子性
- volatile 不会造成线程阻塞；synchronized 可能会造成线程的阻塞
- volatile 标记的变量不会被编译器优化，synchronized 标记的变量可以被编译器优化